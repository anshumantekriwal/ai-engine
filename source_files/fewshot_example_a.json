{
    "success": true,
    "strategy_description": "Buy ETH when RSI(14, 1h) drops below 30 AND price touches the lower Bollinger Band(20, 2). Enter with a limit order at the lower band. $50 margin at 5x leverage. TP at the upper band, SL at 8% ROI. Reset when RSI returns above 50.",
    "initialization_code": "// STEP 1: Strategy classification — Mean Reversion (indicator-driven, limit entry)\n// RSI oversold + BB lower band touch = high-probability reversal setup.\n// One trade idea at a time. Reset when RSI > 50 (neutral zone).\n\nthis.coin = 'ETH';\nthis.leverage = 5;\nthis.marginUsd = 50;\nthis.notionalUsd = this.marginUsd * this.leverage; // $250 notional\nthis.slRoiPct = 8;  // 8% ROI stop-loss = 1.6% price move at 5x\nthis.resetRsiThreshold = 50; // RSI must return above 50 before next entry\n\n// Trade state: one idea at a time\nthis.tradeState = {\n  ideaActive: false,\n  entryPrice: null,\n  entrySize: 0,\n  pendingLimitOrderId: null, // Track unfilled limit order\n  lastRsi: null,             // Latest RSI from trigger system\n  lastBbLower: null,         // Latest BB lower band from trigger\n  lastBbUpper: null,         // Latest BB upper band from trigger\n  rsiResetComplete: true     // Start ready for first trade\n};\n\n// Set leverage before any orders\ntry {\n  await this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n  const actualMax = await this.orderExecutor.getMaxLeverage(this.coin);\n  if (actualMax < this.leverage) {\n    this.leverage = actualMax;\n    this.notionalUsd = this.marginUsd * this.leverage;\n  }\n} catch (e) {\n  console.log(`Leverage set failed: ${e.message}, using default`);\n}\n\n// Fee analysis upfront\nconst mids = await getAllMids();\nconst price = parseFloat(mids[this.coin]) || 3000;\nconst estSize = this.notionalUsd / price;\n\n// Limit order with Alo = maker fee. Estimate with Alo entry, market exit (TP is trigger order)\nconst { totalFee, entryFee, exitFee } = this.orderExecutor.estimateRoundTripFee(\n  estSize, price, price * 1.016, 'Alo', 'market'\n);\nconst slPriceMove = this.slRoiPct / 100 / this.leverage;\nconst grossProfitEst = this.notionalUsd * slPriceMove; // Rough estimate using SL-equivalent move\nconst feeImpactPct = grossProfitEst > 0 ? (totalFee / grossProfitEst) * 100 : 0;\n\nawait this.updateState('init', {\n  coin: this.coin,\n  leverage: this.leverage,\n  margin: this.marginUsd,\n  notional: this.notionalUsd,\n  slRoi: this.slRoiPct,\n  slPriceMove: (slPriceMove * 100).toFixed(2),\n  entryType: 'limit (Alo maker)',\n  entryFee: entryFee.toFixed(4),\n  exitFee: exitFee.toFixed(4),\n  feeImpact: feeImpactPct.toFixed(1)\n},\n  `Strategy initialized: ${this.coin} RSI+BB Mean Reversion. ` +\n  `Composite entry: RSI(14,1h) < 30 AND price at lower BB(20,2). ` +\n  `Limit order at lower band (Alo = maker fee: $${entryFee.toFixed(4)}). ` +\n  `$${this.marginUsd} margin x ${this.leverage} = $${this.notionalUsd} notional. ` +\n  `TP at upper BB (dynamic). SL at ${this.slRoiPct}% ROI (${(slPriceMove * 100).toFixed(2)}% price). ` +\n  `Reset when RSI > ${this.resetRsiThreshold}. Fees ~${feeImpactPct.toFixed(0)}% of target profit.`\n);",
    "trigger_code": "// STEP 2: Trigger architecture — composite trigger for entry, technical trigger for RSI reset\n\n// Entry signal: RSI below 30 AND price below lower Bollinger Band\nthis.registerCompositeTrigger(this.coin, 'AND', [\n  { indicator: 'RSI', params: { period: 14, interval: '1h' }, condition: { below: 30 } },\n  { indicator: 'BollingerBands', params: { period: 20, stdDev: 2, interval: '1h' },\n    condition: { below: 0, checkField: 'lower' } }\n    // NOTE: 'below: 0' won't work for price-vs-band comparison.\n    // The composite trigger checks the indicator VALUE (BB lower band price),\n    // not whether current price < band. We'll use the trigger firing as a signal\n    // that BB lower band is trending down, and check price vs band in executeTrade.\n], async (triggerData) => {\n  // Store latest indicator values from the trigger system\n  for (const sub of triggerData.subResults) {\n    if (sub.indicator === 'RSI') {\n      this.tradeState.lastRsi = typeof sub.value === 'number' ? sub.value : null;\n    }\n    if (sub.indicator === 'BollingerBands' && typeof sub.value === 'object') {\n      this.tradeState.lastBbLower = sub.value.lower;\n      this.tradeState.lastBbUpper = sub.value.upper;\n    }\n  }\n  await this.executeTrade({ ...triggerData, action: 'entry_signal' });\n});\n\n// RSI reset detection: fires when RSI crosses back above 50\nthis.registerTechnicalTrigger(this.coin, 'RSI', { period: 14, interval: '1h' },\n  { crosses_above: this.resetRsiThreshold },\n  async (triggerData) => {\n    this.tradeState.lastRsi = triggerData.value;\n    await this.executeTrade({ ...triggerData, action: 'rsi_reset' });\n  }\n);\n\n// Monitor: report status every 2 minutes using STORED trigger values\nthis.registerScheduledTrigger(2 * 60 * 1000, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});",
    "execution_code": "try {\n  // PHASE 1: Check for external closes (SL/TP filled on exchange)\n  if (this.tradeState.ideaActive) {\n    const openPositions = this.getTrackedOpenPositions();\n    const hasPosition = openPositions.some(p => p.coin === this.coin);\n\n    if (!hasPosition) {\n      // Position was closed externally (SL or TP hit)\n      const recentClosed = this.getTrackedClosedPositions(this.coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n\n      const prev = { ...this.tradeState };\n      this.tradeState.ideaActive = false;\n      this.tradeState.entryPrice = null;\n      this.tradeState.entrySize = 0;\n      this.tradeState.pendingLimitOrderId = null;\n      this.tradeState.rsiResetComplete = false; // Must wait for RSI > 50 before next entry\n\n      await this.updateState('external_close', {\n        coin: this.coin,\n        prevEntry: prev.entryPrice,\n        pnl: lastPnl ? lastPnl.net.toFixed(4) : null,\n        roiPct: lastPnl ? lastPnl.percent.toFixed(2) : null\n      },\n        `${this.coin}: Position closed (SL/TP hit). ` +\n        `Was LONG ${prev.entrySize.toFixed(6)} @ $${prev.entryPrice?.toFixed(2)}` +\n        (lastPnl ? `. PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}% ROI)` : '') +\n        `. Waiting for RSI reset above ${this.resetRsiThreshold} before next entry.`\n      );\n      return;\n    }\n\n    // Check if we have a pending limit order that hasn't filled yet\n    if (this.tradeState.pendingLimitOrderId) {\n      const openOrders = await this.orderExecutor.getOpenOrders(this.coin);\n      const limitStillOpen = openOrders.some(o => o.orderId === this.tradeState.pendingLimitOrderId);\n\n      if (!limitStillOpen && !hasPosition) {\n        // Limit order was cancelled or expired without filling\n        this.tradeState.pendingLimitOrderId = null;\n        this.tradeState.ideaActive = false;\n        await this.updateState('limit_expired', {\n          coin: this.coin\n        }, `${this.coin}: Limit entry order expired/cancelled. Ready for next signal.`);\n        return;\n      }\n    }\n  }\n\n  // PHASE 2: Handle RSI reset signal\n  if (triggerData.action === 'rsi_reset') {\n    if (!this.tradeState.rsiResetComplete) {\n      this.tradeState.rsiResetComplete = true;\n      await this.updateState('rsi_reset', {\n        coin: this.coin,\n        rsi: this.tradeState.lastRsi?.toFixed(2)\n      },\n        `${this.coin}: RSI crossed above ${this.resetRsiThreshold} ` +\n        `(current: ${this.tradeState.lastRsi?.toFixed(2)}). Reset complete — ready for next entry signal.`\n      );\n    }\n    return;\n  }\n\n  // PHASE 3: Handle scheduled monitor (status report)\n  if (triggerData.type === 'scheduled') {\n    const pnlData = this.getPnlSummary();\n    const openPos = this.getTrackedOpenPositions().find(p => p.coin === this.coin);\n\n    if (openPos) {\n      // In position — report held position status\n      const currentMids = await getAllMids();\n      const currentPrice = parseFloat(currentMids[this.coin]) || 0;\n      const unrealizedPct = openPos.entry.price > 0\n        ? ((currentPrice - openPos.entry.price) / openPos.entry.price * 100 * this.leverage).toFixed(2)\n        : 'N/A';\n\n      await this.updateState('monitor_position', {\n        coin: this.coin,\n        side: 'LONG',\n        entryPrice: openPos.entry.price.toFixed(2),\n        currentPrice: currentPrice.toFixed(2),\n        unrealizedRoi: unrealizedPct,\n        lastRsi: this.tradeState.lastRsi?.toFixed(2),\n        bbUpper: this.tradeState.lastBbUpper?.toFixed(2),\n        totalTrades: pnlData.totalTrades,\n        netPnl: pnlData.totalNetPnl.toFixed(4)\n      },\n        `${this.coin} LONG held: entry $${openPos.entry.price.toFixed(2)}, ` +\n        `now $${currentPrice.toFixed(2)} (${unrealizedPct}% ROI). ` +\n        `RSI: ${this.tradeState.lastRsi?.toFixed(1) || 'pending'}. ` +\n        `TP target: upper BB $${this.tradeState.lastBbUpper?.toFixed(2) || 'pending'}. ` +\n        `Stats: ${pnlData.totalTrades} trades, $${pnlData.totalNetPnl.toFixed(4)} net PnL.`\n      );\n    } else {\n      // Idle — report waiting status\n      await this.updateState('monitor_idle', {\n        coin: this.coin,\n        lastRsi: this.tradeState.lastRsi?.toFixed(2),\n        bbLower: this.tradeState.lastBbLower?.toFixed(2),\n        bbUpper: this.tradeState.lastBbUpper?.toFixed(2),\n        rsiResetComplete: this.tradeState.rsiResetComplete,\n        totalTrades: pnlData.totalTrades,\n        netPnl: pnlData.totalNetPnl.toFixed(4)\n      },\n        `${this.coin} idle. RSI: ${this.tradeState.lastRsi?.toFixed(1) || 'awaiting first calc'}. ` +\n        `BB: $${this.tradeState.lastBbLower?.toFixed(2) || '?'} — $${this.tradeState.lastBbUpper?.toFixed(2) || '?'}. ` +\n        `Reset: ${this.tradeState.rsiResetComplete ? 'ready' : 'waiting for RSI > ' + this.resetRsiThreshold}. ` +\n        `Stats: ${pnlData.totalTrades} trades, $${pnlData.totalNetPnl.toFixed(4)} net PnL.`\n      );\n    }\n    return;\n  }\n\n  // PHASE 4: Handle entry signal from composite trigger\n  if (triggerData.action !== 'entry_signal') return;\n\n  // Gate: must have RSI reset and no active trade\n  if (this.tradeState.ideaActive) {\n    await this.updateState('skip_active', {\n      coin: this.coin,\n      rsi: this.tradeState.lastRsi?.toFixed(2)\n    }, `${this.coin}: Composite signal fired but already in trade. Skipping.`);\n    return;\n  }\n\n  if (!this.tradeState.rsiResetComplete) {\n    await this.updateState('skip_no_reset', {\n      coin: this.coin,\n      rsi: this.tradeState.lastRsi?.toFixed(2)\n    },\n      `${this.coin}: Composite signal fired but RSI hasn't reset above ${this.resetRsiThreshold} yet ` +\n      `(last RSI: ${this.tradeState.lastRsi?.toFixed(1) || 'N/A'}). Waiting for reset.`\n    );\n    return;\n  }\n\n  // Get current price and BB lower band for limit order placement\n  const currentMids = await getAllMids();\n  const currentPrice = parseFloat(currentMids[this.coin]);\n  if (!currentPrice) {\n    await this.updateState('error', { coin: this.coin },\n      `${this.coin}: Cannot fetch price. Skipping entry.`);\n    return;\n  }\n\n  // Use BB lower band from trigger data as limit price\n  const limitPrice = this.tradeState.lastBbLower;\n  if (!limitPrice || limitPrice <= 0) {\n    await this.updateState('error', { coin: this.coin },\n      `${this.coin}: BB lower band not available yet. Skipping entry.`);\n    return;\n  }\n\n  // Position sizing: $50 margin * 5x = $250 notional\n  const size = this.notionalUsd / currentPrice;\n\n  // Validate minimum notional\n  if (this.notionalUsd < 10) {\n    await this.updateState('skip_min_size', { coin: this.coin, notional: this.notionalUsd },\n      `${this.coin}: Notional $${this.notionalUsd} below $10 minimum.`);\n    return;\n  }\n\n  // Safety check\n  const safetyCheck = await this.checkSafetyLimits(this.coin, size);\n  if (!safetyCheck.allowed) {\n    await this.updateState('skip_safety', { coin: this.coin, reason: safetyCheck.reason },\n      `${this.coin}: Safety blocked — ${safetyCheck.reason}.`);\n    return;\n  }\n\n  // Place LIMIT order at BB lower band with Alo (maker fee)\n  const limitResult = await this.orderExecutor.placeLimitOrder(\n    this.coin,\n    true,        // buy\n    size,\n    limitPrice,\n    false,       // not reduce-only\n    false,       // not postOnly\n    'Alo'        // add-liquidity-only = guaranteed maker fee\n  );\n\n  if (!limitResult.success) {\n    await this.updateState('order_failed', {\n      coin: this.coin,\n      error: limitResult.error,\n      limitPrice: limitPrice.toFixed(2)\n    }, `${this.coin}: Limit order failed — ${limitResult.error}. Will retry on next signal.`);\n    return;\n  }\n\n  // Check if limit filled immediately or is resting\n  const filled = limitResult.filledSize || 0;\n  const fillPrice = limitResult.averagePrice || limitPrice;\n\n  if (limitResult.status === 'filled' && filled > 0) {\n    // Filled immediately — proceed with SL/TP\n    await this.logTrade({\n      coin: this.coin,\n      side: 'buy',\n      size: filled,\n      price: fillPrice,\n      order_type: 'limit_alo',\n      order_id: limitResult.orderId,\n      is_entry: true,\n      trigger_reason: `RSI ${this.tradeState.lastRsi?.toFixed(1)} + BB lower ${limitPrice.toFixed(2)}`,\n      fee: limitResult.fee,\n      fee_rate: limitResult.feeRate\n    });\n\n    // SL: 8% ROI = 1.6% price move at 5x\n    const slPriceMove = this.slRoiPct / 100 / this.leverage;\n    const slPrice = fillPrice * (1 - slPriceMove);\n\n    // TP: upper Bollinger Band (dynamic target from trigger data)\n    const tpPrice = this.tradeState.lastBbUpper || fillPrice * (1 + slPriceMove * 2);\n\n    const slResult = await this.orderExecutor.placeStopLoss(\n      this.coin, false, filled, slPrice, null, true\n    );\n    const tpResult = await this.orderExecutor.placeTakeProfit(\n      this.coin, false, filled, tpPrice, null, true\n    );\n\n    this.registerSlTpOrders(this.coin, { sl: slResult, tp: tpResult });\n\n    this.tradeState.ideaActive = true;\n    this.tradeState.entryPrice = fillPrice;\n    this.tradeState.entrySize = filled;\n    this.tradeState.pendingLimitOrderId = null;\n\n    await this.reconcileTrackedPositions();\n\n    const tpRoi = tpPrice > fillPrice\n      ? ((tpPrice - fillPrice) / fillPrice * 100 * this.leverage).toFixed(1)\n      : 'N/A';\n\n    await this.updateState('trade_opened', {\n      coin: this.coin,\n      side: 'LONG',\n      size: filled.toFixed(6),\n      price: fillPrice.toFixed(2),\n      notional: (filled * fillPrice).toFixed(2),\n      orderType: 'limit_alo',\n      rsi: this.tradeState.lastRsi?.toFixed(2),\n      bbLower: limitPrice.toFixed(2),\n      slPrice: slPrice.toFixed(2),\n      tpPrice: tpPrice.toFixed(2),\n      tpRoi: tpRoi,\n      fee: (limitResult.fee || 0).toFixed(4)\n    },\n      `${this.coin} LONG opened via limit (Alo maker). ` +\n      `${filled.toFixed(6)} ETH @ $${fillPrice.toFixed(2)} ($${(filled * fillPrice).toFixed(2)} notional). ` +\n      `Signal: RSI ${this.tradeState.lastRsi?.toFixed(1)}, BB lower $${limitPrice.toFixed(2)}. ` +\n      `SL: $${slPrice.toFixed(2)} (-${this.slRoiPct}% ROI). ` +\n      `TP: $${tpPrice.toFixed(2)} (upper BB, ~${tpRoi}% ROI). ` +\n      `Entry fee: $${(limitResult.fee || 0).toFixed(4)} (maker rate).`\n    );\n  } else {\n    // Order resting — track it\n    this.tradeState.ideaActive = true;\n    this.tradeState.pendingLimitOrderId = limitResult.orderId;\n\n    await this.updateState('limit_placed', {\n      coin: this.coin,\n      limitPrice: limitPrice.toFixed(2),\n      size: size.toFixed(6),\n      orderId: limitResult.orderId,\n      rsi: this.tradeState.lastRsi?.toFixed(2)\n    },\n      `${this.coin}: Limit BUY placed at $${limitPrice.toFixed(2)} (BB lower band, Alo maker). ` +\n      `${size.toFixed(6)} ETH ($${this.notionalUsd} notional). ` +\n      `RSI: ${this.tradeState.lastRsi?.toFixed(1)}. Waiting for fill...`\n    );\n  }\n\n} catch (error) {\n  console.log(`Execution error: ${error.message}`);\n  await this.updateState('error', {\n    coin: this.coin,\n    error: error.message\n  }, `${this.coin}: Error — ${error.message}. Will retry on next signal.`);\n}",
    "error": null
}

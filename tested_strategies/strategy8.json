{
    "success": true,
    "initialization_code": "// STEP 1: This is a scheduled portfolio rotation strategy (momentum-based pairs)\n// Trade idea: every 5 minutes, long top momentum coin, short bottom momentum coin\n// Reset: automatic — rankings recomputed fresh each cycle\n\n// Strategy parameters\nthis.coins = ['BTC', 'ETH', 'SOL', 'DOGE'];\nthis.rebalanceIntervalMs = 5 * 60 * 1000; // 5 minutes\nthis.tradeAmountUsd = 10; // $10 notional per position\nthis.leverage = 5;\nthis.slRoiPct = 10; // 10% ROI stop-loss = 2% price move at 5x\n\n// STEP 4: Set leverage for all coins before any orders\nfor (const coin of this.coins) {\n  await this.orderExecutor.setLeverage(coin, this.leverage, true);\n}\n\n// Position tracking: which coins we currently hold and in what direction\n// Store both coin symbol and size for proper position management\nthis.currentPositions = {\n  long: null,  // { coin: string, size: number } or null\n  short: null  // { coin: string, size: number } or null\n};\n\n// Performance tracking\nthis.totalRebalances = 0;\nthis.totalRotations = 0;\n\n// STEP 5: Detailed init message\nawait this.updateState('init', {\n  coins: this.coins,\n  interval: '5 minutes',\n  tradeAmount: this.tradeAmountUsd,\n  leverage: this.leverage,\n  slRoi: this.slRoiPct,\n  marginPerPosition: (this.tradeAmountUsd / this.leverage).toFixed(2),\n  totalMargin: (2 * this.tradeAmountUsd / this.leverage).toFixed(2)\n}, `Strategy initialized: Momentum Pairs on ${this.coins.join(', ')}. Every 5 minutes, ` +\n   `will long the strongest (by 24h % change) and short the weakest. $${this.tradeAmountUsd} ` +\n   `per position at ${this.leverage}x leverage ($${(this.tradeAmountUsd / this.leverage).toFixed(2)} ` +\n   `margin each, $${(2 * this.tradeAmountUsd / this.leverage).toFixed(2)} total). ` +\n   `SL at ${this.slRoiPct}% ROI (${(this.slRoiPct / this.leverage).toFixed(1)}% price move). ` +\n   `Starting first analysis now.`);\n\nthis.logger.info('Momentum pairs strategy initialized', {\n  coins: this.coins,\n  rebalanceInterval: this.rebalanceIntervalMs,\n  leverage: this.leverage\n});",
    "trigger_code": "// STEP 2: HTTP-polling architecture via scheduled trigger\n// We need 24h momentum stats to rank coins — getTicker provides this\n// No WebSocket needed — we're rebalancing on a fixed schedule, not reacting to real-time events\n\nthis.registerScheduledTrigger(this.rebalanceIntervalMs, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});",
    "execution_code": "try {\n  // STEP 3: Trade idea lifecycle — rankings are recomputed fresh each cycle\n  // PHASE 1: Detect external closes (SL hits) and reset tracking\n  const trackedPositions = this.getTrackedOpenPositions();\n  const trackedCoins = new Set(trackedPositions.map(p => p.coin));\n  \n  // Check if our tracked positions were closed externally\n  if (this.currentPositions.long && !trackedCoins.has(this.currentPositions.long.coin)) {\n    await this.updateState('external_close', {\n      coin: this.currentPositions.long.coin,\n      side: 'long'\n    }, `${this.currentPositions.long.coin} LONG position closed externally (likely SL hit). ` +\n       `Will recompute rankings and reopen if still strongest.`);\n    this.currentPositions.long = null;\n  }\n  \n  if (this.currentPositions.short && !trackedCoins.has(this.currentPositions.short.coin)) {\n    await this.updateState('external_close', {\n      coin: this.currentPositions.short.coin,\n      side: 'short'\n    }, `${this.currentPositions.short.coin} SHORT position closed externally (likely SL hit). ` +\n       `Will recompute rankings and reopen if still weakest.`);\n    this.currentPositions.short = null;\n  }\n\n  // PHASE 2: Fetch 24h momentum data and rank coins\n  const momentumData = [];\n  \n  for (const coin of this.coins) {\n    try {\n      const ticker = await getTicker(coin);\n      momentumData.push({\n        coin,\n        changePercent: parseFloat(ticker.change_percent || '0'),\n        price: parseFloat(ticker.price)\n      });\n    } catch (error) {\n      this.logger.error(`Failed to fetch ticker for ${coin}`, { error: error.message });\n      // Skip this coin if data fetch fails\n    }\n  }\n\n  if (momentumData.length < 2) {\n    await this.updateState('error', {\n      error: 'Insufficient ticker data',\n      coinsReceived: momentumData.length\n    }, `Failed to fetch momentum data for enough coins (got ${momentumData.length}/${this.coins.length}). ` +\n       `Will retry next cycle.`);\n    return;\n  }\n\n  // Sort by 24h change: strongest first, weakest last\n  momentumData.sort((a, b) => b.changePercent - a.changePercent);\n  \n  const strongest = momentumData[0];\n  const weakest = momentumData[momentumData.length - 1];\n  \n  this.totalRebalances++;\n\n  // PHASE 3: Determine if rotation is needed\n  const needLongRotation = !this.currentPositions.long || this.currentPositions.long.coin !== strongest.coin;\n  const needShortRotation = !this.currentPositions.short || this.currentPositions.short.coin !== weakest.coin;\n  \n  // Build momentum summary for logging\n  const momentumSummary = momentumData.map(d => \n    `${d.coin} ${d.changePercent >= 0 ? '+' : ''}${d.changePercent.toFixed(2)}%`\n  ).join(', ');\n\n  // PHASE 4: If no rotation needed, just report status\n  if (!needLongRotation && !needShortRotation) {\n    const pnlData = this.getPnlSummary();\n    await this.updateState('rebalance_hold', {\n      rebalanceCount: this.totalRebalances,\n      strongest: strongest.coin,\n      weakest: weakest.coin,\n      momentumData,\n      netPnl: pnlData.totalNetPnl.toFixed(2),\n      totalTrades: pnlData.totalTrades\n    }, `Rebalance #${this.totalRebalances}: ${strongest.coin} still strongest (${strongest.changePercent >= 0 ? '+' : ''}${strongest.changePercent.toFixed(2)}%, ` +\n       `holding LONG), ${weakest.coin} still weakest (${weakest.changePercent >= 0 ? '+' : ''}${weakest.changePercent.toFixed(2)}%, ` +\n       `holding SHORT). Rankings: ${momentumSummary}. No rotation needed. ` +\n       `Net PnL: $${pnlData.totalNetPnl.toFixed(2)} (${pnlData.totalTrades} trades). Next check in 5 minutes.`);\n    return;\n  }\n\n  // PHASE 5: Rotation needed — close old positions first (exit-first pattern)\n  this.totalRotations++;\n  const closedPositions = [];\n  let totalCloseFees = 0;\n\n  if (needLongRotation && this.currentPositions.long) {\n    const oldLongCoin = this.currentPositions.long.coin;\n    const oldLongPos = trackedPositions.find(p => p.coin === oldLongCoin);\n    \n    if (oldLongPos) {\n      this.clearSlTpOrders(oldLongCoin);\n      await this.orderExecutor.cancelAgentOrders(oldLongCoin);\n      \n      const longCloseResult = await this.orderExecutor.closePosition(oldLongCoin, oldLongPos.entry.size);\n      \n      if (longCloseResult.success) {\n        await this.logTrade({\n          coin: oldLongCoin,\n          side: 'sell',\n          size: oldLongPos.entry.size,\n          price: longCloseResult.averagePrice,\n          order_type: 'close_position',\n          is_exit: true,\n          trigger_reason: 'momentum_rotation',\n          fee: longCloseResult.fee\n        });\n        \n        closedPositions.push(`${oldLongCoin} LONG`);\n        totalCloseFees += longCloseResult.fee || 0;\n        this.currentPositions.long = null;\n      } else {\n        await this.updateState('close_failed', {\n          coin: oldLongCoin,\n          error: longCloseResult.error\n        }, `Failed to close ${oldLongCoin} LONG — ${longCloseResult.error}. Keeping position. Will retry next cycle.`);\n        return; // Don't proceed with rotation if close failed\n      }\n    }\n  }\n\n  if (needShortRotation && this.currentPositions.short) {\n    const oldShortCoin = this.currentPositions.short.coin;\n    const oldShortPos = trackedPositions.find(p => p.coin === oldShortCoin);\n    \n    if (oldShortPos) {\n      this.clearSlTpOrders(oldShortCoin);\n      await this.orderExecutor.cancelAgentOrders(oldShortCoin);\n      \n      const shortCloseResult = await this.orderExecutor.closePosition(oldShortCoin, Math.abs(oldShortPos.entry.size));\n      \n      if (shortCloseResult.success) {\n        await this.logTrade({\n          coin: oldShortCoin,\n          side: 'buy',\n          size: Math.abs(oldShortPos.entry.size),\n          price: shortCloseResult.averagePrice,\n          order_type: 'close_position',\n          is_exit: true,\n          trigger_reason: 'momentum_rotation',\n          fee: shortCloseResult.fee\n        });\n        \n        closedPositions.push(`${oldShortCoin} SHORT`);\n        totalCloseFees += shortCloseResult.fee || 0;\n        this.currentPositions.short = null;\n      } else {\n        await this.updateState('close_failed', {\n          coin: oldShortCoin,\n          error: shortCloseResult.error\n        }, `Failed to close ${oldShortCoin} SHORT — ${shortCloseResult.error}. Keeping position. Will retry next cycle.`);\n        return;\n      }\n    }\n  }\n\n  await this.reconcileTrackedPositions();\n\n  // PHASE 6: Open new positions\n  const openedPositions = [];\n  let totalOpenFees = 0;\n\n  // Open long if needed\n  if (needLongRotation) {\n    const longCoin = strongest.coin;\n    const longPrice = strongest.price;\n    const longSize = this.tradeAmountUsd / longPrice;\n    const longNotional = longSize * longPrice;\n\n    // Validate minimum notional\n    if (longNotional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin: longCoin,\n        notional: longNotional.toFixed(2)\n      }, `${longCoin}: Position $${longNotional.toFixed(2)} below $10 minimum. Skipping LONG entry.`);\n    } else {\n      // Check available balance\n      const balance = await this.orderExecutor.getAvailableBalance();\n      const marginNeeded = this.tradeAmountUsd / this.leverage;\n      \n      if (balance < marginNeeded) {\n        await this.updateState('insufficient_margin', {\n          coin: longCoin,\n          available: balance.toFixed(2),\n          needed: marginNeeded.toFixed(2)\n        }, `${longCoin}: Insufficient margin ($${balance.toFixed(2)} available, need $${marginNeeded.toFixed(2)}). ` +\n           `Skipping LONG entry. Will retry next cycle.`);\n      } else {\n        // Check safety limits before placing order\n        const safetyCheck = await this.checkSafetyLimits(longCoin, true, longSize);\n        if (!safetyCheck.allowed) {\n          await this.updateState('safety_limit', {\n            coin: longCoin,\n            reason: safetyCheck.reason\n          }, `${longCoin}: Safety check failed — ${safetyCheck.reason}. Skipping LONG entry.`);\n        } else {\n          const longResult = await this.orderExecutor.placeMarketOrder(longCoin, true, longSize, false, 0.05);\n          \n          if (longResult.success) {\n            const filled = longResult.filledSize || longSize;\n            const fillPrice = longResult.averagePrice || longPrice;\n            \n            await this.logTrade({\n              coin: longCoin,\n              side: 'buy',\n              size: filled,\n              price: fillPrice,\n              order_type: 'market',\n              is_entry: true,\n              trigger_reason: 'strongest_momentum',\n              fee: longResult.fee\n            });\n            \n            // Place stop-loss (10% ROI = 2% price move at 5x)\n            const slMove = this.slRoiPct / 100 / this.leverage;\n            const slPrice = fillPrice * (1 - slMove);\n            \n            const slResult = await this.orderExecutor.placeStopLoss(longCoin, false, filled, slPrice, null, true);\n            if (slResult.success) {\n              this.registerSlTpOrders(longCoin, { sl: slResult });\n            }\n            \n            // Track position with size\n            this.currentPositions.long = { coin: longCoin, size: filled };\n            openedPositions.push(`${longCoin} LONG ${filled.toFixed(6)} @ $${fillPrice.toFixed(2)}`);\n            totalOpenFees += longResult.fee || 0;\n          } else {\n            await this.updateState('order_failed', {\n              coin: longCoin,\n              side: 'long',\n              error: longResult.error\n            }, `${longCoin}: Failed to open LONG — ${longResult.error}. Will retry next cycle.`);\n          }\n        }\n      }\n    }\n  }\n\n  // Open short if needed\n  if (needShortRotation) {\n    const shortCoin = weakest.coin;\n    const shortPrice = weakest.price;\n    const shortSize = this.tradeAmountUsd / shortPrice;\n    const shortNotional = shortSize * shortPrice;\n\n    if (shortNotional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin: shortCoin,\n        notional: shortNotional.toFixed(2)\n      }, `${shortCoin}: Position $${shortNotional.toFixed(2)} below $10 minimum. Skipping SHORT entry.`);\n    } else {\n      const balance = await this.orderExecutor.getAvailableBalance();\n      const marginNeeded = this.tradeAmountUsd / this.leverage;\n      \n      if (balance < marginNeeded) {\n        await this.updateState('insufficient_margin', {\n          coin: shortCoin,\n          available: balance.toFixed(2),\n          needed: marginNeeded.toFixed(2)\n        }, `${shortCoin}: Insufficient margin ($${balance.toFixed(2)} available, need $${marginNeeded.toFixed(2)}). ` +\n           `Skipping SHORT entry. Will retry next cycle.`);\n      } else {\n        // Check safety limits before placing order\n        const safetyCheck = await this.checkSafetyLimits(shortCoin, false, shortSize);\n        if (!safetyCheck.allowed) {\n          await this.updateState('safety_limit', {\n            coin: shortCoin,\n            reason: safetyCheck.reason\n          }, `${shortCoin}: Safety check failed — ${safetyCheck.reason}. Skipping SHORT entry.`);\n        } else {\n          const shortResult = await this.orderExecutor.placeMarketOrder(shortCoin, false, shortSize, false, 0.05);\n          \n          if (shortResult.success) {\n            const filled = shortResult.filledSize || shortSize;\n            const fillPrice = shortResult.averagePrice || shortPrice;\n            \n            await this.logTrade({\n              coin: shortCoin,\n              side: 'sell',\n              size: filled,\n              price: fillPrice,\n              order_type: 'market',\n              is_entry: true,\n              trigger_reason: 'weakest_momentum',\n              fee: shortResult.fee\n            });\n            \n            // Place stop-loss (10% ROI = 2% price move at 5x)\n            const slMove = this.slRoiPct / 100 / this.leverage;\n            const slPrice = fillPrice * (1 + slMove);\n            \n            const slResult = await this.orderExecutor.placeStopLoss(shortCoin, true, filled, slPrice, null, true);\n            if (slResult.success) {\n              this.registerSlTpOrders(shortCoin, { sl: slResult });\n            }\n            \n            // Track position with size\n            this.currentPositions.short = { coin: shortCoin, size: filled };\n            openedPositions.push(`${shortCoin} SHORT ${filled.toFixed(6)} @ $${fillPrice.toFixed(2)}`);\n            totalOpenFees += shortResult.fee || 0;\n          } else {\n            await this.updateState('order_failed', {\n              coin: shortCoin,\n              side: 'short',\n              error: shortResult.error\n            }, `${shortCoin}: Failed to open SHORT — ${shortResult.error}. Will retry next cycle.`);\n          }\n        }\n      }\n    }\n  }\n\n  await this.reconcileTrackedPositions();\n\n  // PHASE 7: Report rotation results\n  const pnlData = this.getPnlSummary();\n  const totalFees = totalCloseFees + totalOpenFees;\n  \n  let message = `Rebalance #${this.totalRebalances} (Rotation #${this.totalRotations}): `;\n  \n  if (closedPositions.length > 0) {\n    message += `Closed ${closedPositions.join(', ')}. `;\n  }\n  \n  if (openedPositions.length > 0) {\n    message += `Opened ${openedPositions.join(', ')}. `;\n  } else {\n    message += `No new positions opened. `;\n  }\n  \n  message += `Rankings: ${momentumSummary}. `;\n  \n  if (totalFees > 0) {\n    message += `Fees: $${totalFees.toFixed(4)}. `;\n  }\n  \n  message += `Net PnL: $${pnlData.totalNetPnl.toFixed(2)} (${pnlData.totalTrades} trades, ` +\n             `${(pnlData.winRate * 100).toFixed(1)}% win rate). Next check in 5 minutes.`;\n  \n  await this.updateState('rotation_complete', {\n    rebalanceCount: this.totalRebalances,\n    rotationCount: this.totalRotations,\n    closed: closedPositions,\n    opened: openedPositions,\n    momentumData,\n    totalFees: totalFees.toFixed(4),\n    netPnl: pnlData.totalNetPnl.toFixed(2),\n    winRate: (pnlData.winRate * 100).toFixed(1)\n  }, message);\n\n} catch (error) {\n  this.logger.error('Error in executeTrade', { error: error.message, stack: error.stack });\n  await this.updateState('error', {\n    error: error.message,\n    stack: error.stack\n  }, `Error during rebalance: ${error.message}. Will retry next cycle.`);\n}",
    "error": null
}
{
    "success": true,
    "strategy_description": "Monitor BTC and ETH via live price feed. When either drops 0.3% from its 5-minute high, go long with $30 notional at 10x leverage. Trail stop at 1.5%. If both signal simultaneously, pick the one with higher 24h volume. Status updates every 15 seconds.",
    "initialization_code": "// STEP 1: Strategy classification — Event-Driven / WS Scalp (multi-coin)\n// Detect sharp dips from rolling 5-minute highs. One position per coin max.\n// Trailing stop for exit — no fixed TP needed.\n\nthis.coins = ['BTC', 'ETH'];\nthis.leverage = 10;\nthis.notionalUsd = 30; // $30 notional per position = $3 margin at 10x\nthis.dropThresholdPct = 0.3;  // 0.3% drop from 5-min high\nthis.windowMs = 5 * 60 * 1000; // 5-minute rolling window\nthis.trailStopPct = 1.5; // 1.5% trailing stop\nthis.statusIntervalMs = 15 * 1000; // Report every 15s (matches strategy time horizon)\n\n// Per-coin state\nthis.tradeState = {};\nfor (const coin of this.coins) {\n  this.tradeState[coin] = {\n    ideaActive: false,\n    entryPrice: null,\n    entrySize: 0,\n    priceHistory: [], // [{ price, timestamp }, ...] — 5-min rolling window\n    latestPrice: null,\n    lastDropPct: null  // Last observed drop from high (for status reports)\n  };\n}\n\n// Set leverage for all coins\nfor (const coin of this.coins) {\n  try {\n    await this.orderExecutor.setLeverage(coin, this.leverage, true);\n    const actualMax = await this.orderExecutor.getMaxLeverage(coin);\n    if (actualMax < this.leverage) {\n      this.leverage = actualMax;\n    }\n  } catch (e) {\n    console.log(`${coin} leverage set failed: ${e.message}`);\n  }\n}\n\n// Fee analysis\nconst mids = await getAllMids();\nconst btcPrice = parseFloat(mids['BTC']) || 95000;\nconst estSize = this.notionalUsd / btcPrice;\nconst { totalFee } = this.orderExecutor.estimateRoundTripFee(\n  estSize, btcPrice, btcPrice * 1.003 // Assume 0.3% move exit\n);\nconst grossProfit = this.notionalUsd * 0.003;\nconst feeImpactPct = grossProfit > 0 ? (totalFee / grossProfit) * 100 : 0;\n\nawait this.updateState('init', {\n  coins: this.coins,\n  leverage: this.leverage,\n  notional: this.notionalUsd,\n  margin: (this.notionalUsd / this.leverage).toFixed(2),\n  dropThreshold: this.dropThresholdPct,\n  windowSeconds: this.windowMs / 1000,\n  trailStop: this.trailStopPct,\n  statusInterval: this.statusIntervalMs / 1000,\n  feeImpact: feeImpactPct.toFixed(1)\n},\n  `Strategy initialized: Multi-coin dip buyer on ${this.coins.join(', ')}. ` +\n  `WS price monitoring for ${this.dropThresholdPct}% drops from 5-minute high. ` +\n  `$${this.notionalUsd} notional ($${(this.notionalUsd / this.leverage).toFixed(2)} margin) at ${this.leverage}x. ` +\n  `Exit: ${this.trailStopPct}% trailing stop. ` +\n  `Fee impact: ~${feeImpactPct.toFixed(0)}% of a ${this.dropThresholdPct}% recovery. ` +\n  `Status every ${this.statusIntervalMs / 1000}s. Starting WS feed.`\n);",
    "trigger_code": "// STEP 2: WebSocket for real-time price monitoring + scheduled status reports\n\n// Subscribe to live prices — build rolling 5-minute high per coin\nthis.wsManager.subscribeAllMids((data) => {\n  const now = Date.now();\n  const cutoff = now - this.windowMs;\n\n  for (const coin of this.coins) {\n    const px = parseFloat(data.mids[coin]);\n    if (!px) continue;\n\n    const state = this.tradeState[coin];\n    state.latestPrice = px;\n\n    // Add to rolling window\n    state.priceHistory.push({ price: px, timestamp: now });\n\n    // Trim to 5-minute window\n    state.priceHistory = state.priceHistory.filter(p => p.timestamp > cutoff);\n\n    // Calculate drop from HIGHEST price in window (not oldest — key distinction)\n    if (state.priceHistory.length >= 2) {\n      const prices = state.priceHistory.map(p => p.price);\n      const windowHigh = Math.max(...prices);\n      const dropFromHigh = ((px - windowHigh) / windowHigh) * 100;\n      state.lastDropPct = dropFromHigh;\n\n      // Fire entry if drop exceeds threshold and no active position\n      if (dropFromHigh <= -this.dropThresholdPct && !state.ideaActive) {\n        this.executeTrade({\n          type: 'price_drop',\n          action: 'entry_signal',\n          coin: coin,\n          dropPercent: Math.abs(dropFromHigh),\n          windowHigh: windowHigh,\n          currentPrice: px,\n          historyLength: state.priceHistory.length\n        }).catch(err => {\n          this.updateState('ws_error', { coin, error: err.message },\n            `${coin}: Error processing drop signal — ${err.message}`);\n        });\n      }\n    }\n  }\n});\n\n// Status reports every 15 seconds — matches the 5-min monitoring time horizon\nthis.registerScheduledTrigger(this.statusIntervalMs, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});",
    "execution_code": "try {\n  // PHASE 1: External close detection for ALL coins\n  const trackedPositions = this.getTrackedOpenPositions();\n  const trackedCoins = new Set(trackedPositions.map(p => p.coin));\n\n  for (const coin of this.coins) {\n    const state = this.tradeState[coin];\n    if (state.ideaActive && !trackedCoins.has(coin)) {\n      // Position closed externally (trailing stop hit)\n      const recentClosed = this.getTrackedClosedPositions(coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n\n      const prevEntry = state.entryPrice;\n      const prevSize = state.entrySize;\n      state.ideaActive = false;\n      state.entryPrice = null;\n      state.entrySize = 0;\n\n      await this.updateState('external_close', {\n        coin,\n        prevEntry: prevEntry?.toFixed(2),\n        pnl: lastPnl ? lastPnl.net.toFixed(4) : null,\n        roiPct: lastPnl ? lastPnl.percent.toFixed(2) : null\n      },\n        `${coin}: Position closed (trailing stop hit). ` +\n        `Was LONG ${prevSize?.toFixed(6)} @ $${prevEntry?.toFixed(2)}` +\n        (lastPnl ? `. PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}% ROI)` : '') +\n        `. Ready for next dip signal.`\n      );\n    }\n  }\n\n  // PHASE 2: Handle scheduled status report\n  if (triggerData.type === 'scheduled') {\n    const pnlData = this.getPnlSummary();\n    const coinStatuses = [];\n\n    for (const coin of this.coins) {\n      const state = this.tradeState[coin];\n      const px = state.latestPrice;\n\n      if (state.ideaActive) {\n        const unrealizedRoi = state.entryPrice > 0 && px > 0\n          ? ((px - state.entryPrice) / state.entryPrice * 100 * this.leverage).toFixed(2)\n          : 'N/A';\n        coinStatuses.push(\n          `${coin}: LONG @ $${state.entryPrice?.toFixed(2)}, now $${px?.toFixed(2)} (${unrealizedRoi}% ROI)`\n        );\n      } else {\n        const dropStr = state.lastDropPct !== null\n          ? `${state.lastDropPct.toFixed(3)}% from 5m high`\n          : 'building history';\n        coinStatuses.push(\n          `${coin}: $${px?.toFixed(2) || '?'} (${dropStr}, need -${this.dropThresholdPct}%)`\n        );\n      }\n    }\n\n    await this.updateState('status', {\n      coins: this.coins.map(c => ({\n        coin: c,\n        price: this.tradeState[c].latestPrice?.toFixed(2),\n        dropFromHigh: this.tradeState[c].lastDropPct?.toFixed(3),\n        inPosition: this.tradeState[c].ideaActive,\n        historyPoints: this.tradeState[c].priceHistory.length\n      })),\n      totalTrades: pnlData.totalTrades,\n      netPnl: pnlData.totalNetPnl.toFixed(4)\n    },\n      `Monitoring: ${coinStatuses.join(' | ')}. ` +\n      `Stats: ${pnlData.totalTrades} trades, $${pnlData.totalNetPnl.toFixed(4)} net PnL.`\n    );\n    return;\n  }\n\n  // PHASE 3: Handle entry signal\n  if (triggerData.action !== 'entry_signal') return;\n\n  const coin = triggerData.coin;\n  const state = this.tradeState[coin];\n\n  // Double-check gate (WS can fire rapidly)\n  if (state.ideaActive) return;\n\n  // If BOTH coins signal simultaneously, check which has higher volume\n  const otherCoin = this.coins.find(c => c !== coin);\n  const otherState = this.tradeState[otherCoin];\n  if (otherState && !otherState.ideaActive && otherState.lastDropPct !== null\n      && otherState.lastDropPct <= -this.dropThresholdPct) {\n    // Both signaling — compare 24h volume to pick the better trade\n    try {\n      const [tickerA, tickerB] = await Promise.all([\n        getTicker(coin),\n        getTicker(otherCoin)\n      ]);\n      if (tickerB.volume > tickerA.volume) {\n        await this.updateState('skip_lower_volume', {\n          coin,\n          volume: tickerA.volume,\n          preferredCoin: otherCoin,\n          preferredVolume: tickerB.volume\n        },\n          `${coin}: Both coins dropping, but ${otherCoin} has higher 24h volume ` +\n          `(${tickerB.volume.toFixed(0)} vs ${tickerA.volume.toFixed(0)}). Preferring ${otherCoin}.`\n        );\n        return; // Skip this coin, let the other coin's signal handle it\n      }\n    } catch (e) {\n      console.log(`Volume comparison failed: ${e.message}. Proceeding with ${coin}.`);\n    }\n  }\n\n  // Get current price (prefer WS cache)\n  const currentPrice = state.latestPrice || parseFloat((await getAllMids())[coin]);\n  if (!currentPrice) {\n    await this.updateState('error', { coin }, `${coin}: Cannot get price. Skipping.`);\n    return;\n  }\n\n  // Position sizing\n  const size = this.notionalUsd / currentPrice;\n  if (this.notionalUsd < 10) {\n    await this.updateState('skip_min_size', { coin, notional: this.notionalUsd },\n      `${coin}: Notional $${this.notionalUsd} below $10 minimum.`);\n    return;\n  }\n\n  // Safety check (correct: 2 args — coin, size)\n  const safetyCheck = await this.checkSafetyLimits(coin, size);\n  if (!safetyCheck.allowed) {\n    await this.updateState('skip_safety', { coin, reason: safetyCheck.reason },\n      `${coin}: Safety blocked — ${safetyCheck.reason}.`);\n    return;\n  }\n\n  // Fee check before entry\n  const { totalFee, entryFee } = this.orderExecutor.estimateRoundTripFee(\n    size, currentPrice, currentPrice * (1 + this.dropThresholdPct / 100)\n  );\n  const expectedRecovery = this.notionalUsd * (this.dropThresholdPct / 100);\n  if (totalFee >= expectedRecovery * 0.8) {\n    await this.updateState('skip_fee_viability', {\n      coin,\n      totalFee: totalFee.toFixed(4),\n      expectedRecovery: expectedRecovery.toFixed(4)\n    },\n      `${coin}: Fees ($${totalFee.toFixed(4)}) consume >${80}% of expected recovery ` +\n      `($${expectedRecovery.toFixed(4)}). Trade not viable. Skipping.`\n    );\n    return;\n  }\n\n  // Place market order (speed matters for dip buying)\n  const result = await this.orderExecutor.placeMarketOrder(\n    coin, true, size, false, 0.05\n  );\n\n  if (!result.success) {\n    await this.updateState('order_failed', { coin, error: result.error },\n      `${coin}: Order failed — ${result.error}. Will retry on next signal.`);\n    return;\n  }\n\n  const filled = result.filledSize || size;\n  const fillPrice = result.averagePrice || currentPrice;\n  const actualFee = result.fee || entryFee;\n\n  await this.logTrade({\n    coin,\n    side: 'buy',\n    size: filled,\n    price: fillPrice,\n    order_type: 'market',\n    order_id: result.orderId,\n    is_entry: true,\n    trigger_reason: `Drop ${triggerData.dropPercent.toFixed(2)}% from 5m high $${triggerData.windowHigh.toFixed(2)}`,\n    fee: actualFee,\n    fee_rate: result.feeRate\n  });\n\n  // Trailing stop for exit\n  const trailResult = await this.orderExecutor.placeTrailingStop(\n    coin, false, filled, this.trailStopPct, true\n  );\n\n  if (trailResult.success) {\n    this.registerSlTpOrders(coin, { trailing: trailResult });\n  }\n\n  // Update trade state\n  state.ideaActive = true;\n  state.entryPrice = fillPrice;\n  state.entrySize = filled;\n\n  await this.reconcileTrackedPositions();\n\n  await this.updateState('trade_opened', {\n    coin,\n    side: 'LONG',\n    size: filled.toFixed(6),\n    price: fillPrice.toFixed(2),\n    notional: (filled * fillPrice).toFixed(2),\n    dropPercent: triggerData.dropPercent.toFixed(2),\n    windowHigh: triggerData.windowHigh.toFixed(2),\n    trailStop: this.trailStopPct,\n    entryFee: actualFee.toFixed(4)\n  },\n    `${coin} dip detected: $${triggerData.windowHigh.toFixed(2)} → $${fillPrice.toFixed(2)} ` +\n    `(-${triggerData.dropPercent.toFixed(2)}% from 5m high). ` +\n    `Opened LONG ${filled.toFixed(6)} @ $${fillPrice.toFixed(2)} ($${(filled * fillPrice).toFixed(2)} notional). ` +\n    `Trail stop: ${this.trailStopPct}%. Entry fee: $${actualFee.toFixed(4)}.`\n  );\n\n} catch (error) {\n  console.log(`Execution error: ${error.message}`);\n  await this.updateState('error', {\n    error: error.message\n  }, `Error — ${error.message}. Will retry on next signal.`);\n}",
    "error": null
}

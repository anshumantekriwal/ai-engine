{
    "success": true,
    "initialization_code": "// STRATEGY CLASS: Funding/Carry — hold short while high funding persists\n// DATA: HTTP polling (funding updates every 8h, no need for real-time WS)\n// LIFECYCLE: Enter when funding > 0.01%, exit when < 0.005%, reset after exit\n\ntry {\n  // Configuration\n  this.coin = 'SOL';\n  this.tradeNotional = 25;  // $25 notional (user said \"including leverage\")\n  this.leverage = 10;  // Default leverage\n  this.entryThreshold = 0.01;  // 0.01% funding (enter short)\n  this.exitThreshold = 0.005;  // 0.005% funding (exit short)\n  this.checkInterval = 2 * 60 * 60 * 1000;  // Check every 2 hours\n  this.safetySL = 10;  // 10% ROI stop-loss (in case funding spikes + price pumps)\n\n  // Set leverage\n  await this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n\n  // Initialize trade state\n  this.tradeState = {\n    ideaActive: false,\n    entryPrice: null,\n    entrySize: 0,\n    entryFundingRate: null,\n    lastFundingCheck: null\n  };\n\n  // Check if we already have a position from a previous run\n  const existingPos = this.positionTracker.getOpenPosition(this.coin);\n  if (existingPos && existingPos.entry.side === 'sell') {\n    // Resume tracking existing short\n    this.tradeState = {\n      ideaActive: true,\n      entryPrice: existingPos.entry.price,\n      entrySize: existingPos.entry.size,\n      entryFundingRate: null,  // Unknown from previous run\n      lastFundingCheck: Date.now()\n    };\n    await this.updateState('init_resume', {\n      coin: this.coin,\n      entryPrice: existingPos.entry.price,\n      entrySize: existingPos.entry.size\n    }, `Strategy initialized: SOL funding arbitrage (resumed existing position). ` +\n       `Currently SHORT ${existingPos.entry.size.toFixed(4)} SOL @ $${existingPos.entry.price.toFixed(2)}. ` +\n       `Will exit when predicted funding drops below ${this.exitThreshold}%. ` +\n       `Checking every 2 hours.`);\n  } else {\n    await this.updateState('init', {\n      coin: this.coin,\n      notional: this.tradeNotional,\n      leverage: this.leverage,\n      entryThreshold: this.entryThreshold,\n      exitThreshold: this.exitThreshold\n    }, `Strategy initialized: SOL funding arbitrage. Will SHORT when predicted funding rate ` +\n       `exceeds ${this.entryThreshold}%, hold until it drops below ${this.exitThreshold}%. ` +\n       `Trade size: $${this.tradeNotional} notional at ${this.leverage}x leverage ` +\n       `(margin: $${(this.tradeNotional / this.leverage).toFixed(2)}). ` +\n       `Safety stop-loss: ${this.safetySL}% ROI. Checking every 2 hours.`);\n  }\n} catch (error) {\n  await this.updateState('init_error', {\n    error: error.message\n  }, `Initialization failed: ${error.message}`);\n  throw error;\n}",
    "trigger_code": "// Use scheduled trigger — funding rates update every 8h, no need for real-time monitoring\n// Check every 2 hours to catch funding changes reasonably quickly\n\nthis.registerScheduledTrigger(this.checkInterval, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});\n\nawait this.updateState('trigger_setup', {\n  interval: this.checkInterval / 1000 / 60,\n  intervalUnit: 'minutes'\n}, `Scheduled trigger registered: checking funding rate every ${this.checkInterval / 1000 / 60 / 60} hours.`);",
    "execution_code": "try {\n  // PHASE 1: Detect external closes (safety SL hit, manual close, etc.)\n  if (this.tradeState.ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(this.coin);\n    if (!trackedPos) {\n      const prev = this.tradeState;\n      this.tradeState = {\n        ideaActive: false,\n        entryPrice: null,\n        entrySize: 0,\n        entryFundingRate: null,\n        lastFundingCheck: Date.now()\n      };\n      const recentClosed = this.positionTracker.getClosedPositions(this.coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n      await this.updateState('external_close', {\n        coin: this.coin,\n        prevEntry: prev.entryPrice,\n        prevSize: prev.entrySize,\n        pnl: lastPnl?.net?.toFixed(4)\n      }, `${this.coin}: Position closed externally (likely safety SL hit). ` +\n         `Was SHORT ${prev.entrySize.toFixed(4)} @ $${prev.entryPrice.toFixed(2)}` +\n         (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}%)` : '') +\n         `. State reset — ready for next funding signal.`);\n      return;\n    }\n  }\n\n  // PHASE 2: Fetch current funding rate\n  const fundingData = await getPredictedFundings();\n  let currentFundingRate = null;\n  \n  // Parse the funding data structure: [[\"BTC\", [[funding_arrays]]], ...]\n  for (const [coin, fundingArrays] of fundingData) {\n    if (coin === this.coin) {\n      // fundingArrays is nested: [[funding values]]\n      // The first element of the inner array is the predicted funding rate\n      if (fundingArrays && fundingArrays[0] && fundingArrays[0].length > 0) {\n        currentFundingRate = parseFloat(fundingArrays[0][0]);\n      }\n      break;\n    }\n  }\n\n  if (currentFundingRate === null) {\n    await this.updateState('error', {\n      coin: this.coin,\n      error: 'Could not fetch funding rate'\n    }, `${this.coin}: Unable to fetch predicted funding rate. Will retry in 2 hours.`);\n    return;\n  }\n\n  this.tradeState.lastFundingCheck = Date.now();\n  const fundingPct = (currentFundingRate * 100).toFixed(4);  // Convert to percentage\n\n  // Get current price\n  const mids = await getAllMids();\n  const currentPrice = parseFloat(mids[this.coin]);\n\n  // PHASE 3: Check exit condition (if in position)\n  if (this.tradeState.ideaActive) {\n    // Exit if funding drops below exit threshold\n    if (currentFundingRate < this.exitThreshold / 100) {\n      // Close the position\n      this.clearSlTpOrders(this.coin);\n      await this.orderExecutor.cancelAgentOrders(this.coin);\n      \n      const closeResult = await this.orderExecutor.closePosition(\n        this.coin,\n        this.tradeState.entrySize\n      );\n\n      if (!closeResult.success) {\n        await this.updateState('close_failed', {\n          coin: this.coin,\n          error: closeResult.error,\n          fundingRate: fundingPct\n        }, `${this.coin}: Failed to close SHORT position — ${closeResult.error}. ` +\n           `Funding: ${fundingPct}% (below exit threshold ${this.exitThreshold}%). ` +\n           `Will retry on next check.`);\n        return;\n      }\n\n      const exitPrice = closeResult.averagePrice || currentPrice;\n      const exitSize = closeResult.filledSize || this.tradeState.entrySize;\n      \n      await this.logTrade({\n        coin: this.coin,\n        side: 'buy',  // Buying to close short\n        size: exitSize,\n        price: exitPrice,\n        order_type: 'close_position',\n        is_exit: true,\n        trigger_reason: `Funding dropped to ${fundingPct}% (exit threshold: ${this.exitThreshold}%)`\n      });\n      await this.reconcileTrackedPositions();\n\n      // Get PnL from tracker\n      const recentClosedAfterExit = this.positionTracker.getClosedPositions(this.coin, 1);\n      const pnl = recentClosedAfterExit.length > 0 ? recentClosedAfterExit[0].pnl : null;\n\n      // Reset state\n      this.tradeState = {\n        ideaActive: false,\n        entryPrice: null,\n        entrySize: 0,\n        entryFundingRate: null,\n        lastFundingCheck: Date.now()\n      };\n\n      await this.updateState('exit', {\n        coin: this.coin,\n        exitPrice,\n        exitSize,\n        fundingRate: fundingPct,\n        pnl: pnl?.net?.toFixed(4),\n        pnlPercent: pnl?.percent?.toFixed(2)\n      }, `${this.coin}: Closed SHORT — ${exitSize.toFixed(4)} @ $${exitPrice.toFixed(2)}. ` +\n         `Funding dropped to ${fundingPct}% (below ${this.exitThreshold}% threshold). ` +\n         (pnl ? `Realized PnL: $${pnl.net.toFixed(4)} (${pnl.percent.toFixed(2)}%). ` : '') +\n         `Ready for next entry signal when funding rises above ${this.entryThreshold}%.`);\n      return;\n    }\n\n    // Still in position — report status\n    const trackedPosHold = this.positionTracker.getOpenPosition(this.coin);\n    const unrealizedPnl = trackedPosHold ? \n      (this.tradeState.entryPrice - currentPrice) * this.tradeState.entrySize : 0;\n    \n    await this.updateState('hold', {\n      coin: this.coin,\n      entryPrice: this.tradeState.entryPrice,\n      entrySize: this.tradeState.entrySize,\n      currentPrice,\n      fundingRate: fundingPct,\n      unrealizedPnl: unrealizedPnl.toFixed(4)\n    }, `${this.coin}: SHORT active (${this.tradeState.entrySize.toFixed(4)} @ ` +\n       `$${this.tradeState.entryPrice.toFixed(2)}). Current funding: ${fundingPct}%, ` +\n       `still above exit threshold (${this.exitThreshold}%). ` +\n       `Unrealized PnL: $${unrealizedPnl.toFixed(4)}. Next check in 2 hours.`);\n    return;\n  }\n\n  // PHASE 4: Check entry condition (if not in position)\n  if (currentFundingRate > this.entryThreshold / 100) {\n    // Calculate position size\n    const size = this.tradeNotional / currentPrice;\n    const notional = size * currentPrice;\n\n    // Validate minimum notional\n    if (notional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin: this.coin,\n        notional: notional.toFixed(2),\n        fundingRate: fundingPct\n      }, `${this.coin}: Position $${notional.toFixed(2)} below $10 minimum. ` +\n         `Funding ${fundingPct}% above threshold, but cannot trade. Skipping.`);\n      return;\n    }\n\n    // Check safety limits\n    const safetyCheck = await this.checkSafetyLimits(this.coin, size);\n    if (!safetyCheck.allowed) {\n      await this.updateState('skip_safety', {\n        coin: this.coin,\n        reason: safetyCheck.reason,\n        fundingRate: fundingPct\n      }, `${this.coin}: Safety limit reached — ${safetyCheck.reason}. ` +\n         `Funding ${fundingPct}% signals SHORT, but cannot trade.`);\n      return;\n    }\n\n    // Estimate fees\n    const { totalFee } = this.orderExecutor.estimateRoundTripFee(size, currentPrice);\n\n    // Place SHORT order\n    const orderResult = await this.orderExecutor.placeMarketOrder(\n      this.coin,\n      false,  // isBuy = false (SHORT)\n      size,\n      false,  // reduceOnly\n      0.05    // 5% slippage\n    );\n\n    if (!orderResult.success) {\n      await this.updateState('order_failed', {\n        coin: this.coin,\n        error: orderResult.error,\n        fundingRate: fundingPct\n      }, `${this.coin}: Failed to open SHORT — ${orderResult.error}. ` +\n         `Funding: ${fundingPct}%. Will retry on next signal.`);\n      return;\n    }\n\n    const fillPrice = orderResult.averagePrice || currentPrice;\n    const filled = orderResult.filledSize || size;\n    const actualNotional = filled * fillPrice;\n\n    // Log trade\n    await this.logTrade({\n      coin: this.coin,\n      side: 'sell',\n      size: filled,\n      price: fillPrice,\n      order_type: 'market',\n      order_id: orderResult.orderId,\n      is_entry: true,\n      trigger_reason: `Funding rate ${fundingPct}% (threshold: ${this.entryThreshold}%)`\n    });\n    await this.reconcileTrackedPositions();\n\n    // Update state\n    this.tradeState = {\n      ideaActive: true,\n      entryPrice: fillPrice,\n      entrySize: filled,\n      entryFundingRate: currentFundingRate,\n      lastFundingCheck: Date.now()\n    };\n\n    // Place safety stop-loss (10% ROI = 1% price move at 10x leverage)\n    const slMove = this.safetySL / 100 / this.leverage;\n    const slPrice = fillPrice * (1 + slMove);  // Short position, SL is above entry\n    \n    const slResult = await this.orderExecutor.placeStopLoss(\n      this.coin,\n      true,   // isBuy = true (buy to close short)\n      filled,\n      slPrice,\n      null,\n      true\n    );\n\n    if (slResult.success) {\n      this.registerSlTpOrders(this.coin, { sl: slResult });\n    }\n\n    await this.updateState('entry', {\n      coin: this.coin,\n      side: 'short',\n      size: filled,\n      price: fillPrice,\n      notional: actualNotional.toFixed(2),\n      leverage: this.leverage,\n      fundingRate: fundingPct,\n      exitThreshold: this.exitThreshold,\n      slPrice: slPrice.toFixed(2),\n      estimatedFee: totalFee.toFixed(4)\n    }, `${this.coin}: Opened SHORT — ${filled.toFixed(4)} @ $${fillPrice.toFixed(2)} ` +\n       `($${actualNotional.toFixed(2)} notional, ${this.leverage}x leverage). ` +\n       `Triggered by funding rate: ${fundingPct}% (threshold: ${this.entryThreshold}%). ` +\n       `Will hold until funding drops below ${this.exitThreshold}%. ` +\n       `Safety SL at $${slPrice.toFixed(2)}. Estimated round-trip fee: $${totalFee.toFixed(4)}.`);\n    return;\n  }\n\n  // PHASE 5: No signal — report idle status\n  await this.updateState('idle', {\n    coin: this.coin,\n    fundingRate: fundingPct,\n    entryThreshold: this.entryThreshold,\n    price: currentPrice.toFixed(2)\n  }, `${this.coin}: Funding rate ${fundingPct}% — below entry threshold (${this.entryThreshold}%). ` +\n     `No position. Current price: $${currentPrice.toFixed(2)}. Next check in 2 hours.`);\n\n} catch (error) {\n  await this.updateState('error', {\n    coin: this.coin,\n    error: error.message,\n    stack: error.stack\n  }, `${this.coin}: Error in executeTrade — ${error.message}. Will retry on next scheduled check.`);\n}",
    "error": null
}
{
    "success": true,
    "initialization_code": "// STEP 1: Strategy classification — Mean Reversion / Event-Driven Scalp\n// We're buying quick dips (0.1% in <10s) expecting immediate bounce.\n// Each drop is ONE trade idea — no re-entry until position exits and new drop forms.\n\nthis.coin = 'BTC';\nthis.leverage = 50;  // Max leverage for BTC\nthis.tradeAmountUsd = 50;  // Minimum viable scalp size\n\n// User specified PRICE MOVE percentages (not ROI)\nthis.dropThresholdPct = 0.1;   // Enter on 0.1% drop\nthis.tpPricePct = 0.15;         // TP at +0.15% price move\nthis.slPricePct = 0.08;         // SL at -0.08% price move\nthis.dropWindowMs = 10000;      // 10 second window for drop detection\n\n// Price history for velocity tracking (rolling 10s window)\nthis.priceHistory = [];  // [{ price, timestamp }, ...]\n\n// Trade state tracking (prevent duplicate entries on same drop event)\nthis.tradeState = {\n  ideaActive: false,      // True when in position or drop event still unfolding\n  entryPrice: null,\n  entrySize: 0,\n  dropDetectedAt: null    // Timestamp of last drop detection\n};\n\n// Status reporting\nthis.lastStatusUpdate = Date.now();\nthis.statusIntervalMs = 60000;  // Report every 60s when idle\n\n// STEP 4: Set leverage BEFORE any orders\ntry {\n  await this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n  const actualMax = await this.orderExecutor.getMaxLeverage(this.coin);\n  if (actualMax < this.leverage) {\n    this.leverage = actualMax;\n  }\n} catch (error) {\n  await this.updateState('init_error', { error: error.message },\n    `Failed to set leverage: ${error.message}. Using default.`);\n}\n\n// STEP 5: Calculate fee impact and warn user\nconst currentMids = await getAllMids();\nconst estimatedPrice = parseFloat(currentMids[this.coin]) || 94000;\nconst estimatedSize = this.tradeAmountUsd / estimatedPrice;\nconst { totalFee } = this.orderExecutor.estimateRoundTripFee(\n  estimatedSize, estimatedPrice, estimatedPrice * 1.0015  // Assume TP hit\n);\nconst grossProfitPerWin = this.tradeAmountUsd * (this.tpPricePct / 100);\nconst feeImpactPct = (totalFee / grossProfitPerWin) * 100;\n\nawait this.updateState('init', {\n  coin: this.coin,\n  leverage: this.leverage,\n  tradeAmount: this.tradeAmountUsd,\n  dropThreshold: this.dropThresholdPct,\n  tpPrice: this.tpPricePct,\n  slPrice: this.slPricePct,\n  dropWindow: this.dropWindowMs / 1000,\n  feeImpact: feeImpactPct.toFixed(1)\n},\n  `Strategy initialized: BTC Scalping with ${this.leverage}x leverage. ` +\n  `Monitoring for ${this.dropThresholdPct}% price drops within ${this.dropWindowMs / 1000} seconds. ` +\n  `Entry: $${this.tradeAmountUsd} position on drop detection. ` +\n  `Exit: +${this.tpPricePct}% TP (price move) or -${this.slPricePct}% SL (price move). ` +\n  `At ${this.leverage}x leverage: TP = ${(this.tpPricePct * this.leverage).toFixed(1)}% ROI, ` +\n  `SL = ${(this.slPricePct * this.leverage).toFixed(1)}% ROI loss. ` +\n  `⚠️ FEE WARNING: Round-trip fees ($${totalFee.toFixed(4)}) consume ~${feeImpactPct.toFixed(0)}% ` +\n  `of gross profit per winning trade. Need >${(100 - feeImpactPct).toFixed(0)}% win rate for profitability. ` +\n  `Continuous monitoring active.`\n);",
    "trigger_code": "// STEP 2: WebSocket-driven architecture (REQUIRED for sub-second monitoring)\n// Subscribe to live price feed and build rolling 10-second price history\n\nthis.latestPrice = null;\n\n// Pattern 1: WebSocket live price cache\nthis.wsManager.subscribeAllMids((data) => {\n  const now = Date.now();\n  const btcPrice = parseFloat(data.mids[this.coin]);\n  \n  if (!btcPrice) return;\n  \n  this.latestPrice = btcPrice;\n  \n  // Add to price history\n  this.priceHistory.push({ price: btcPrice, timestamp: now });\n  \n  // Trim history to 10-second window\n  const cutoff = now - this.dropWindowMs;\n  this.priceHistory = this.priceHistory.filter(p => p.timestamp > cutoff);\n  \n  // STEP 3: Detect drop events in real-time\n  // Only check if we have enough history and not already in a trade idea\n  if (this.priceHistory.length >= 2 && !this.tradeState.ideaActive) {\n    const oldest = this.priceHistory[0];\n    const newest = this.priceHistory[this.priceHistory.length - 1];\n    const timeDiff = newest.timestamp - oldest.timestamp;\n    \n    // Only evaluate if we have at least 2 seconds of data (avoid false triggers)\n    if (timeDiff >= 2000) {\n      const priceChange = ((newest.price - oldest.price) / oldest.price) * 100;\n      \n      // Check if price dropped >= threshold within the window\n      if (priceChange <= -this.dropThresholdPct) {\n        // Trigger found — fire executeTrade\n        this.executeTrade({\n          type: 'price_drop',\n          coin: this.coin,\n          dropPercent: Math.abs(priceChange),\n          timeDiff: timeDiff / 1000,\n          fromPrice: oldest.price,\n          toPrice: newest.price,\n          currentPrice: btcPrice\n        }).catch(err => {\n          this.updateState('execution_error', { error: err.message },\n            `Error processing drop signal: ${err.message}`);\n        });\n      }\n    }\n  }\n});\n\n// Scheduled status updates when idle (every 60s)\nthis.registerScheduledTrigger(this.statusIntervalMs, async () => {\n  // Only report if no active position (avoid spam during trades)\n  if (!this.tradeState.ideaActive && this.latestPrice) {\n    // Calculate 10s price range for context\n    if (this.priceHistory.length >= 2) {\n      const prices = this.priceHistory.map(p => p.price);\n      const min = Math.min(...prices);\n      const max = Math.max(...prices);\n      const rangePct = ((max - min) / min) * 100;\n      \n      await this.updateState('status', {\n        price: this.latestPrice.toFixed(2),\n        range10s: rangePct.toFixed(3),\n        historyPoints: this.priceHistory.length\n      },\n        `${this.coin} monitoring active. Price: $${this.latestPrice.toFixed(2)}. ` +\n        `10s range: $${min.toFixed(2)}-$${max.toFixed(2)} (${rangePct.toFixed(3)}% spread). ` +\n        `No qualifying drops detected. Watching for ${this.dropThresholdPct}% drops.`\n      );\n    }\n  }\n});",
    "execution_code": "try {\n  // STEP 3: Trade idea lifecycle — check for external closes first\n  // Pattern 8: External close detection using position tracker\n  if (this.tradeState.ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(this.coin);\n    \n    if (!trackedPos) {\n      // Position was closed externally (SL/TP hit)\n      const prev = this.tradeState;\n      this.tradeState = {\n        ideaActive: false,\n        entryPrice: null,\n        entrySize: 0,\n        dropDetectedAt: null\n      };\n      \n      // Get PnL from closed position history\n      const recentClosed = this.getTrackedClosedPositions(this.coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n      \n      await this.updateState('external_close', {\n        coin: this.coin,\n        prevEntry: prev.entryPrice,\n        prevSize: prev.entrySize,\n        pnl: lastPnl ? lastPnl.net.toFixed(4) : null,\n        roiPct: lastPnl ? lastPnl.percent.toFixed(2) : null\n      },\n        `${this.coin}: Position closed externally (TP/SL hit). ` +\n        `Was ${prev.entrySize.toFixed(6)} BTC @ $${prev.entryPrice.toFixed(2)}` +\n        (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}% ROI)` : '') +\n        `. Ready for next drop signal.`\n      );\n      \n      return;  // Exit early — state is reset, ready for new signals\n    }\n  }\n  \n  // If this is a scheduled status trigger (not a price drop), just return\n  if (triggerData.type === 'scheduled') {\n    return;\n  }\n  \n  // STEP 3: Pattern 7 — Trade idea gating (prevent duplicate entries)\n  if (this.tradeState.ideaActive) {\n    await this.updateState('skip_duplicate', {\n      coin: this.coin,\n      dropPercent: triggerData.dropPercent ? triggerData.dropPercent.toFixed(3) : null,\n      currentPrice: triggerData.currentPrice ? triggerData.currentPrice.toFixed(2) : null,\n      entryPrice: this.tradeState.entryPrice,\n      entrySize: this.tradeState.entrySize\n    },\n      `${this.coin}: Drop detected (${triggerData.dropPercent ? triggerData.dropPercent.toFixed(2) : 'N/A'}% in ${triggerData.timeDiff ? triggerData.timeDiff.toFixed(1) : 'N/A'}s) ` +\n      `but already in position from prior drop (${this.tradeState.entrySize.toFixed(6)} BTC @ ` +\n      `$${this.tradeState.entryPrice.toFixed(2)}). Waiting for exit before next entry.`\n    );\n    return;\n  }\n  \n  // Get current price (prefer WS cache, fallback to HTTP)\n  const currentPrice = this.latestPrice || parseFloat((await getAllMids())[this.coin]);\n  \n  if (!currentPrice) {\n    await this.updateState('error', { coin: this.coin },\n      `${this.coin}: Unable to fetch current price. Skipping signal.`);\n    return;\n  }\n  \n  // STEP 4: Position sizing — Pattern 4\n  const size = this.tradeAmountUsd / currentPrice;\n  const notional = size * currentPrice;\n  \n  // Validate minimum notional\n  if (notional < 10) {\n    await this.updateState('skip_min_size', {\n      coin: this.coin,\n      notional: notional.toFixed(2)\n    },\n      `${this.coin}: Position $${notional.toFixed(2)} below $10 minimum. Skipping.`);\n    return;\n  }\n  \n  // Check safety limits\n  const safetyCheck = await this.checkSafetyLimits(this.coin, size);\n  if (!safetyCheck.allowed) {\n    await this.updateState('skip_safety', {\n      coin: this.coin,\n      reason: safetyCheck.reason\n    },\n      `${this.coin}: Safety check failed — ${safetyCheck.reason}. Skipping entry.`);\n    return;\n  }\n  \n  // STEP 4: Calculate fees BEFORE entering (Pattern 6)\n  const tpPrice = currentPrice * (1 + this.tpPricePct / 100);\n  const { totalFee, entryFee } = this.orderExecutor.estimateRoundTripFee(\n    size, currentPrice, tpPrice\n  );\n  const expectedGrossProfit = notional * (this.tpPricePct / 100);\n  const netProfitIfWin = expectedGrossProfit - totalFee;\n  \n  // Place market order for speed (scalping requires immediate execution)\n  const result = await this.orderExecutor.placeMarketOrder(\n    this.coin,\n    true,  // buy\n    size,\n    false,  // not reduce-only\n    0.05    // 5% slippage tolerance\n  );\n  \n  if (!result.success) {\n    await this.updateState('order_failed', {\n      coin: this.coin,\n      error: result.error,\n      size: size.toFixed(6)\n    },\n      `${this.coin}: Order failed — ${result.error}. Will retry on next drop signal.`);\n    return;\n  }\n  \n  // Use filled data with fallbacks (Pattern 1 rule)\n  const filled = result.filledSize || size;\n  const fillPrice = result.averagePrice || currentPrice;\n  const actualFee = result.fee || entryFee;\n  \n  // Log the trade\n  await this.logTrade({\n    coin: this.coin,\n    side: 'buy',\n    size: filled,\n    price: fillPrice,\n    order_type: 'market',\n    order_id: result.orderId,\n    is_entry: true,\n    trigger_reason: `Drop ${triggerData.dropPercent ? triggerData.dropPercent.toFixed(2) : 'N/A'}% in ${triggerData.timeDiff ? triggerData.timeDiff.toFixed(1) : 'N/A'}s`,\n    fee: actualFee,\n    fee_rate: result.feeRate\n  });\n  \n  // STEP 4: Place SL/TP using PRICE MOVE (user specified price %, not ROI)\n  // Pattern 5 adapted for price move instead of ROI\n  const slPrice = fillPrice * (1 - this.slPricePct / 100);  // -0.08% price\n  const tpPriceFinal = fillPrice * (1 + this.tpPricePct / 100);  // +0.15% price\n  \n  // SL/TP isBuy is CLOSE direction (opposite of position)\n  const slResult = await this.orderExecutor.placeStopLoss(\n    this.coin,\n    false,  // sell to close long\n    filled,\n    slPrice,\n    null,   // auto 3% slippage\n    true    // reduce-only\n  );\n  \n  const tpResult = await this.orderExecutor.placeTakeProfit(\n    this.coin,\n    false,  // sell to close long\n    filled,\n    tpPriceFinal,\n    null,   // auto 1% slippage\n    true    // reduce-only\n  );\n  \n  // Register SL/TP for automatic fill detection (Pattern 5)\n  this.registerSlTpOrders(this.coin, {\n    sl: slResult,\n    tp: tpResult\n  });\n  \n  // Update trade state — mark idea as active\n  this.tradeState = {\n    ideaActive: true,\n    entryPrice: fillPrice,\n    entrySize: filled,\n    dropDetectedAt: Date.now()\n  };\n  \n  // Reconcile positions\n  await this.reconcileTrackedPositions();\n  \n  // Calculate ROI equivalents for user context\n  const tpRoi = this.tpPricePct * this.leverage;\n  const slRoi = this.slPricePct * this.leverage;\n  \n  // STEP 5: Detailed trade notification\n  await this.updateState('trade_opened', {\n    coin: this.coin,\n    side: 'LONG',\n    size: filled.toFixed(6),\n    price: fillPrice.toFixed(2),\n    notional: (filled * fillPrice).toFixed(2),\n    leverage: this.leverage,\n    dropPercent: triggerData.dropPercent ? triggerData.dropPercent.toFixed(2) : null,\n    dropTime: triggerData.timeDiff ? triggerData.timeDiff.toFixed(1) : null,\n    fromPrice: triggerData.fromPrice ? triggerData.fromPrice.toFixed(2) : null,\n    slPrice: slPrice.toFixed(2),\n    tpPrice: tpPriceFinal.toFixed(2),\n    entryFee: actualFee.toFixed(4),\n    totalFee: totalFee.toFixed(4),\n    expectedNetProfit: netProfitIfWin.toFixed(4)\n  },\n    `${this.coin} drop detected: $${triggerData.fromPrice ? triggerData.fromPrice.toFixed(2) : 'N/A'}→$${triggerData.toPrice ? triggerData.toPrice.toFixed(2) : 'N/A'} ` +\n    `(-${triggerData.dropPercent ? triggerData.dropPercent.toFixed(2) : 'N/A'}%, ${triggerData.timeDiff ? triggerData.timeDiff.toFixed(1) : 'N/A'}s). ` +\n    `Opened LONG — ${filled.toFixed(6)} BTC @ $${fillPrice.toFixed(2)} ` +\n    `($${(filled * fillPrice).toFixed(2)} notional, ${this.leverage}x leverage). ` +\n    `TP: $${tpPriceFinal.toFixed(2)} (+${this.tpPricePct}% price = ${tpRoi.toFixed(1)}% ROI), ` +\n    `SL: $${slPrice.toFixed(2)} (-${this.slPricePct}% price = ${slRoi.toFixed(1)}% ROI loss). ` +\n    `Entry fee: $${actualFee.toFixed(4)}. Round-trip fee: $${totalFee.toFixed(4)}. ` +\n    `Expected net profit if TP: $${netProfitIfWin.toFixed(4)}.`\n  );\n  \n} catch (error) {\n  await this.updateState('execution_error', {\n    coin: this.coin,\n    error: error.message,\n    stack: error.stack\n  },\n    `${this.coin}: Execution error — ${error.message}. Will retry on next signal.`);\n}",
    "error": null
}
{
    "success": true,
    "initialization_code": "// STEP 1: STRATEGY CLASSIFICATION\n// This is a mean reversion strategy. \"Dip\" and \"pump\" are excursions from equilibrium.\n// Re-entry only after price returns to neutral zone and previous position closes.\n\n// STEP 4: POSITION MANAGEMENT PARAMETERS\nthis.coins = ['ETH', 'SOL'];\nthis.leverage = 10;  // Moderate leverage for mean reversion\nthis.accountPercent = 0.15;  // 15% of account per trade (this is MARGIN)\nthis.slRoiPct = 8;  // 8% ROI stop-loss (0.8% price move at 10x)\nthis.tpRoiPct = 12;  // 12% ROI take-profit (1.2% price move at 10x)\nthis.checkInterval = 5 * 60 * 1000;  // Check every 5 minutes\n\n// Mean reversion thresholds: % change from recent mean to trigger signal\nthis.dipThreshold = -3.0;  // Long when price drops >3% from 1h average\nthis.pumpThreshold = 3.0;  // Short when price rises >3% from 1h average\nthis.neutralZone = 1.5;  // Reset when price within ±1.5% of mean\n\n// STEP 3: TRADE IDEA LIFECYCLE TRACKING\n// Track per-coin: ideaActive (in trade?), lastSignal (long/short), entryPrice, entrySize, lastDeviation\nthis.tradeState = {};\nfor (const coin of this.coins) {\n  this.tradeState[coin] = {\n    ideaActive: false,\n    lastSignal: null,  // 'long' or 'short'\n    entryPrice: null,\n    entrySize: 0,\n    lastDeviation: 0  // Track last % deviation to detect resets\n  };\n}\n\n// Set leverage for all coins BEFORE any orders\ntry {\n  for (const coin of this.coins) {\n    await this.orderExecutor.setLeverage(coin, this.leverage, true);\n  }\n} catch (error) {\n  await this.updateState('leverage_error', {\n    error: error.message\n  }, `Failed to set leverage: ${error.message}`);\n  throw error;\n}\n\n// STEP 5: DETAILED INIT MESSAGE\nconst accountValue = await this.orderExecutor.getAccountValue();\nconst marginPerTrade = accountValue * this.accountPercent;\nconst notionalPerTrade = marginPerTrade * this.leverage;\nconst slPriceMove = (this.slRoiPct / 100 / this.leverage * 100).toFixed(2);\nconst tpPriceMove = (this.tpRoiPct / 100 / this.leverage * 100).toFixed(2);\n\nawait this.updateState('init', {\n  coins: this.coins,\n  leverage: this.leverage,\n  accountPercent: this.accountPercent,\n  marginPerTrade: marginPerTrade.toFixed(2),\n  notionalPerTrade: notionalPerTrade.toFixed(2),\n  slRoi: this.slRoiPct,\n  tpRoi: this.tpRoiPct,\n  dipThreshold: this.dipThreshold,\n  pumpThreshold: this.pumpThreshold\n}, `Mean Reversion Strategy initialized on ${this.coins.join(', ')}. ` +\n   `Will LONG on dips >${Math.abs(this.dipThreshold)}%, SHORT on pumps >${this.pumpThreshold}%. ` +\n   `Position size: 15% of account (~$${marginPerTrade.toFixed(0)} margin = $${notionalPerTrade.toFixed(0)} notional at ${this.leverage}x leverage). ` +\n   `Risk: SL at ${this.slRoiPct}% ROI (${slPriceMove}% price move), TP at ${this.tpRoiPct}% ROI (${tpPriceMove}% price move). ` +\n   `Checking every 5 minutes for price deviations from 1-hour mean.`);\n\nawait this.reconcileTrackedPositions();",
    "trigger_code": "// STEP 2: DATA ARCHITECTURE — Scheduled HTTP polling\n// Mean reversion doesn't need sub-second monitoring. Check every 5 minutes.\n// Will fetch candles to compute 1h average price and current deviation.\n\nthis.registerScheduledTrigger(this.checkInterval, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});\n\nawait this.updateState('triggers_registered', {\n  interval: this.checkInterval / 1000\n}, `Scheduled trigger registered: checking for mean reversion signals every ${this.checkInterval / 1000} seconds.`);",
    "execution_code": "try {\n  // STEP 3: TRADE IDEA LIFECYCLE — Check for external closes first (Pattern 8)\n  for (const coin of this.coins) {\n    if (this.tradeState[coin].ideaActive) {\n      const trackedPos = this.positionTracker.getOpenPosition(coin);\n      if (!trackedPos) {\n        // Position was closed externally (SL/TP hit)\n        const prev = this.tradeState[coin];\n        \n        // Clear any remaining SL/TP orders\n        this.clearSlTpOrders(coin);\n        \n        this.tradeState[coin] = {\n          ideaActive: false,\n          lastSignal: null,\n          entryPrice: null,\n          entrySize: 0,\n          lastDeviation: 0\n        };\n        const recentClosed = this.getTrackedClosedPositions(coin, 1);\n        const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n        await this.updateState('external_close', {\n          coin,\n          prevEntry: prev.entryPrice,\n          prevSize: prev.entrySize,\n          prevSignal: prev.lastSignal,\n          pnl: lastPnl?.net?.toFixed(4)\n        }, `${coin}: Position closed externally (SL/TP likely hit). Was ${prev.lastSignal?.toUpperCase()} ` +\n           `${prev.entrySize.toFixed(4)} @ $${prev.entryPrice.toFixed(2)}` +\n           (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}%)` : '') +\n           `. State reset — ready for next signal.`);\n      }\n    }\n  }\n\n  // STEP 2: FETCH DATA — Get current prices and 1h candle history for mean calculation\n  const mids = await getAllMids();\n  const now = Date.now();\n  const oneHourAgo = now - 60 * 60 * 1000;\n\n  const signals = [];\n  const coinSummaries = [];\n\n  // PHASE 1: ANALYZE EACH COIN\n  for (const coin of this.coins) {\n    const currentPrice = parseFloat(mids[coin]);\n    if (!currentPrice) {\n      coinSummaries.push(`${coin}: price unavailable`);\n      continue;\n    }\n\n    // Fetch 1h candles to compute average price (mean)\n    const candles = await getCandleSnapshot(coin, '5m', oneHourAgo, now);\n    if (!candles || candles.length < 6) {\n      coinSummaries.push(`${coin}: insufficient candle data`);\n      continue;\n    }\n\n    // Compute 1h average price (simple mean of close prices)\n    const avgPrice = candles.reduce((sum, c) => sum + parseFloat(c.close), 0) / candles.length;\n    const deviation = ((currentPrice - avgPrice) / avgPrice) * 100;  // % deviation from mean\n\n    // Update last deviation for reset detection\n    const prevDeviation = this.tradeState[coin].lastDeviation;\n    this.tradeState[coin].lastDeviation = deviation;\n\n    // STEP 3: CHECK FOR RESET (price returned to neutral zone)\n    if (this.tradeState[coin].ideaActive) {\n      if (Math.abs(deviation) <= this.neutralZone) {\n        // Price normalized — reset state to allow re-entry\n        this.tradeState[coin].ideaActive = false;\n        this.tradeState[coin].lastSignal = null;\n        await this.updateState('reset', {\n          coin, deviation: deviation.toFixed(2), neutralZone: this.neutralZone\n        }, `${coin}: Price returned to neutral zone (${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}% from mean). ` +\n           `State reset — ready for next signal.`);\n      } else {\n        // Still in trade, still deviated — skip\n        const pos = this.positionTracker.getOpenPosition(coin);\n        if (pos) {\n          coinSummaries.push(\n            `${coin}: ${deviation > 0 ? 'elevated' : 'depressed'} (${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}%) ` +\n            `but already have ${pos.entry.side.toUpperCase()} position (${pos.entry.size.toFixed(4)} @ $${pos.entry.price.toFixed(2)})`\n          );\n        }\n        continue;\n      }\n    }\n\n    // STEP 3: DETECT SIGNALS (dip or pump)\n    let signal = null;\n    if (deviation <= this.dipThreshold) {\n      signal = 'long';  // Price dipped — expect bounce\n    } else if (deviation >= this.pumpThreshold) {\n      signal = 'short';  // Price pumped — expect pullback\n    }\n\n    if (signal) {\n      // STEP 3: TRADE IDEA GATING — Prevent duplicate entries (Pattern 7)\n      if (this.tradeState[coin].ideaActive && this.tradeState[coin].lastSignal === signal) {\n        coinSummaries.push(\n          `${coin}: Still ${signal === 'long' ? 'dipped' : 'pumped'} (${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}%) ` +\n          `but already in ${signal.toUpperCase()} from this excursion`\n        );\n        continue;\n      }\n\n      signals.push({ coin, signal, currentPrice, avgPrice, deviation });\n    } else {\n      // No signal — price in neutral zone or not extreme enough\n      coinSummaries.push(\n        `${coin}: ${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}% from mean ` +\n        `(need ${deviation > 0 ? '>' + this.pumpThreshold : '<' + this.dipThreshold}%)`\n      );\n    }\n  }\n\n  // PHASE 2: EXECUTE SIGNALS\n  for (const sig of signals) {\n    const { coin, signal, currentPrice, avgPrice, deviation } = sig;\n    const isBuy = signal === 'long';\n\n    // STEP 4: POSITION SIZING — 15% of account margin\n    const accountValue = await this.orderExecutor.getAccountValue();\n    const marginAmount = accountValue * this.accountPercent;\n    const notionalAmount = marginAmount * this.leverage;\n    let size = notionalAmount / currentPrice;\n\n    // Safety: cap with max trade sizes\n    const maxSizes = await this.orderExecutor.getMaxTradeSizes(coin);\n    const maxSize = isBuy ? maxSizes.maxLong : maxSizes.maxShort;\n    if (size > maxSize) {\n      size = maxSize;\n    }\n\n    // Validate minimum $10 notional\n    const finalNotional = size * currentPrice;\n    if (finalNotional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin, notional: finalNotional.toFixed(2), signal\n      }, `${coin}: Position $${finalNotional.toFixed(2)} below $10 minimum. Skipping ${signal.toUpperCase()} signal.`);\n      continue;\n    }\n\n    // STEP 4: FEE VIABILITY CHECK (Pattern 6)\n    const tpPriceMove = this.tpRoiPct / 100 / this.leverage;\n    const { totalFee } = this.orderExecutor.estimateRoundTripFee(size, currentPrice);\n    const expectedGrossProfit = size * currentPrice * tpPriceMove;\n    const feeRatio = totalFee / expectedGrossProfit;\n\n    // Block trade if fees consume >50% of expected profit\n    if (feeRatio > 0.5) {\n      await this.updateState('skip_fee_ratio', {\n        coin, feeRatio: (feeRatio * 100).toFixed(1), signal\n      }, `${coin}: Fees (${(feeRatio * 100).toFixed(1)}% of expected profit) too high. Skipping ${signal.toUpperCase()} signal.`);\n      continue;\n    }\n\n    // Safety check\n    const safetyCheck = await this.checkSafetyLimits(coin, size);\n    if (!safetyCheck.allowed) {\n      await this.updateState('safety_block', {\n        coin, reason: safetyCheck.reason, signal\n      }, `${coin}: ${signal.toUpperCase()} signal blocked — ${safetyCheck.reason}`);\n      continue;\n    }\n\n    // PLACE MARKET ORDER\n    const orderResult = await this.orderExecutor.placeMarketOrder(coin, isBuy, size, false, 0.05);\n    if (!orderResult.success) {\n      await this.updateState('order_failed', {\n        coin, signal, error: orderResult.error\n      }, `${coin}: Failed to open ${signal.toUpperCase()} — ${orderResult.error}. Will retry on next signal.`);\n      continue;\n    }\n\n    const filled = orderResult.filledSize || size;\n    const fillPrice = orderResult.averagePrice || currentPrice;\n\n    // Log the trade\n    await this.logTrade({\n      coin,\n      side: isBuy ? 'buy' : 'sell',\n      size: filled,\n      price: fillPrice,\n      order_type: 'market',\n      order_id: orderResult.orderId || null,\n      trigger_reason: `${signal} signal: ${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}% deviation from 1h mean`,\n      is_entry: true,\n      fee: orderResult.fee || null,\n      fee_rate: orderResult.feeRate || null\n    });\n\n    // STEP 4: PLACE SL/TP (Pattern 5 — ROI-based)\n    const slMove = this.slRoiPct / 100 / this.leverage;\n    const tpMove = this.tpRoiPct / 100 / this.leverage;\n    const slPrice = isBuy ? fillPrice * (1 - slMove) : fillPrice * (1 + slMove);\n    const tpPrice = isBuy ? fillPrice * (1 + tpMove) : fillPrice * (1 - tpMove);\n\n    const slResult = await this.orderExecutor.placeStopLoss(coin, !isBuy, filled, slPrice, null, true);\n    const tpResult = await this.orderExecutor.placeTakeProfit(coin, !isBuy, filled, tpPrice, null, true);\n\n    if (slResult.success && tpResult.success) {\n      this.registerSlTpOrders(coin, { sl: slResult, tp: tpResult });\n    }\n\n    await this.reconcileTrackedPositions();\n\n    // STEP 3: MARK TRADE IDEA AS ACTIVE (Pattern 7)\n    this.tradeState[coin] = {\n      ideaActive: true,\n      lastSignal: signal,\n      entryPrice: fillPrice,\n      entrySize: filled,\n      lastDeviation: deviation\n    };\n\n    // STEP 5: DETAILED TRADE MESSAGE\n    await this.updateState('trade_opened', {\n      coin,\n      signal,\n      size: filled.toFixed(4),\n      price: fillPrice.toFixed(2),\n      notional: (filled * fillPrice).toFixed(2),\n      leverage: this.leverage,\n      deviation: deviation.toFixed(2),\n      avgPrice: avgPrice.toFixed(2),\n      slPrice: slPrice.toFixed(2),\n      tpPrice: tpPrice.toFixed(2),\n      fee: orderResult.fee?.toFixed(4) || 'N/A',\n      feeRatio: (feeRatio * 100).toFixed(1)\n    }, `${coin}: Opened ${signal.toUpperCase()} — ${filled.toFixed(4)} ${coin} @ $${fillPrice.toFixed(2)} ` +\n       `($${(filled * fillPrice).toFixed(2)} notional, ${this.leverage}x leverage). ` +\n       `Triggered by ${deviation > 0 ? 'pump' : 'dip'}: ${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}% from 1h mean ($${avgPrice.toFixed(2)}). ` +\n       `SL at $${slPrice.toFixed(2)} (${this.slRoiPct}% ROI), TP at $${tpPrice.toFixed(2)} (${this.tpRoiPct}% ROI). ` +\n       `Fee: $${orderResult.fee?.toFixed(4) || 'N/A'} (~${(feeRatio * 100).toFixed(1)}% of expected profit).`);\n  }\n\n  // PHASE 3: REPORT IDLE STATE IF NO SIGNALS (Pattern 14)\n  if (signals.length === 0 && coinSummaries.length > 0) {\n    const pnl = this.getPnlSummary();\n    const openPositions = this.getTrackedOpenPositions();\n    const openSummary = openPositions.map(p =>\n      `${p.coin} ${p.entry.side.toUpperCase()} ${p.entry.size.toFixed(4)} @ $${p.entry.price.toFixed(2)}`\n    ).join(', ') || 'none';\n\n    await this.updateState('cycle_summary', {\n      coinSummaries,\n      totalTrades: pnl.totalTrades,\n      netPnl: pnl.totalNetPnl.toFixed(2),\n      openPositions: openPositions.length\n    }, `Analysis complete — no signals. ${coinSummaries.join('. ')}. ` +\n       `Open positions: ${openSummary}. ` +\n       (pnl.totalTrades > 0 ? `Performance: ${pnl.totalTrades} trades, Net PnL: $${pnl.totalNetPnl.toFixed(2)}, Win rate: ${(pnl.winRate * 100).toFixed(1)}%. ` : '') +\n       `Next check in 5 minutes.`);\n  }\n\n} catch (error) {\n  await this.updateState('error', {\n    error: error.message,\n    stack: error.stack\n  }, `Error in executeTrade: ${error.message}. Will retry on next cycle.`);\n}",
    "error": null
}
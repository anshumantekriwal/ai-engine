{
    "success": true,
    "initialization_code": "// STEP 1: CLASSIFY — Hybrid trend/momentum with mean reversion entry\n// RSI < 35 = oversold (reversion), MACD > 0 = bullish momentum\n// Re-entry: only after RSI resets above 50 AND drops below 35 again\n\nthis.coin = 'BTC';\nthis.leverage = 5;\nthis.riskPerTrade = 2;  // Risk $2 per trade\nthis.atrMultiplier = 1.5;  // Stop at 1.5x ATR\nthis.rsiPeriod = 14;\nthis.rsiThreshold = 35;\nthis.rsiResetLevel = 50;  // Must cross above this before re-entry\nthis.interval = '1h';  // Timeframe for indicators\nthis.checkInterval = 60000;  // Check every 1 minute\n\n// STEP 3: TRADE IDEA LIFECYCLE\n// ideaActive: true when in position from current RSI excursion\n// entryPrice: track entry for stop calculation\n// entrySize: track size for sandboxed close\n// entryAtr: ATR value at entry (for stop distance)\nthis.tradeState = {\n  ideaActive: false,\n  entryPrice: null,\n  entrySize: 0,\n  entryAtr: null\n};\n\n// STEP 4: LEVERAGE — set before any orders\nawait this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n\n// STEP 5: DETAILED INIT MESSAGE\nconst atrStopPct = (this.atrMultiplier * 100).toFixed(1);  // e.g. \"150%\"\nawait this.updateState('init', {\n  coin: this.coin,\n  leverage: this.leverage,\n  riskPerTrade: this.riskPerTrade,\n  atrMultiplier: this.atrMultiplier,\n  rsiThreshold: this.rsiThreshold,\n  interval: this.interval\n}, `Strategy initialized: RSI-MACD Momentum Dip on ${this.coin}. Will buy when RSI < ${this.rsiThreshold} AND MACD histogram > 0 (oversold dip in uptrend). Position sizing: risk $${this.riskPerTrade} per trade with stop at ${this.atrMultiplier}× ATR below entry. Leverage: ${this.leverage}x. The agent checks indicators every minute and enters when both conditions align. Exits when RSI resets above ${this.rsiResetLevel} or MACD momentum fades. This combines mean reversion entries with trend confirmation for high-probability dip buying.`);\n\nthis.log('RSI-MACD Momentum Dip agent initialized for BTC');",
    "trigger_code": "// STEP 2: DATA ARCHITECTURE — Composite trigger for entry + scheduled for monitoring\n\n// Entry signal: RSI < 35 AND MACD histogram > 0\n// Using composite trigger with AND logic (Pattern 11)\nthis.registerCompositeTrigger(\n  this.coin,\n  'AND',\n  [\n    {\n      indicator: 'RSI',\n      params: { period: this.rsiPeriod, interval: this.interval },\n      condition: { below: this.rsiThreshold }\n    },\n    {\n      indicator: 'MACD',\n      params: { fastPeriod: 12, slowPeriod: 26, signalPeriod: 9, interval: this.interval },\n      condition: { checkField: 'histogram', above: 0 }\n    }\n  ],\n  async (triggerData) => {\n    // triggerData.subResults contains both RSI and MACD values\n    await this.executeTrade({ ...triggerData, action: 'entry' });\n  }\n);\n\n// Scheduled trigger for exit monitoring and status updates\n// Check every minute for: RSI reset, MACD reversal, external closes\nthis.registerScheduledTrigger(this.checkInterval, async (triggerData) => {\n  await this.executeTrade({ ...triggerData, action: 'monitor' });\n});",
    "execution_code": "try {\n  const { action, type, subResults } = triggerData;\n\n  // STEP 3 & Pattern 8: External close detection (SL hit)\n  // Check if position was closed externally before any logic\n  if (this.tradeState.ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(this.coin);\n    if (!trackedPos) {\n      // Position closed externally (stop loss hit)\n      const prev = this.tradeState;\n      this.tradeState = { ideaActive: false, entryPrice: null, entrySize: 0, entryAtr: null };\n      \n      const recentClosed = this.getTrackedClosedPositions(this.coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n      \n      await this.updateState('external_close', {\n        coin: this.coin,\n        prevEntry: prev.entryPrice,\n        prevSize: prev.entrySize,\n        stopDistance: (prev.entryAtr * this.atrMultiplier).toFixed(2),\n        pnl: lastPnl?.net?.toFixed(2)\n      }, `${this.coin}: Position closed externally (stop loss likely hit at $${(prev.entryPrice - prev.entryAtr * this.atrMultiplier).toFixed(2)}). ` +\n         `Was ${prev.entrySize.toFixed(6)} BTC @ $${prev.entryPrice.toFixed(2)}` +\n         (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(2)} (${lastPnl.percent.toFixed(2)}%)` : '') +\n         `. State reset — ready for next RSI < ${this.rsiThreshold} signal.`);\n      return;\n    }\n  }\n\n  // ENTRY LOGIC — Composite trigger fired\n  if (action === 'entry' && type === 'composite') {\n    // Pattern 7: Check if we're already in a trade from this RSI excursion\n    if (this.tradeState.ideaActive) {\n      const rsiValue = subResults.find(r => r.indicator === 'RSI')?.value;\n      const macdValue = subResults.find(r => r.indicator === 'MACD')?.value?.histogram;\n      \n      await this.updateState('skip_duplicate', {\n        coin: this.coin,\n        rsi: rsiValue?.toFixed(1),\n        macdHist: macdValue?.toFixed(2),\n        entryPrice: this.tradeState.entryPrice,\n        entrySize: this.tradeState.entrySize,\n        stopPrice: (this.tradeState.entryPrice - this.tradeState.entryAtr * this.atrMultiplier).toFixed(2)\n      }, `${this.coin}: RSI still oversold (${rsiValue?.toFixed(1)}) and MACD histogram positive (${macdValue?.toFixed(2)}), ` +\n         `but already have position from this excursion (${this.tradeState.entrySize.toFixed(6)} BTC @ $${this.tradeState.entryPrice.toFixed(2)}). ` +\n         `Stop at $${(this.tradeState.entryPrice - this.tradeState.entryAtr * this.atrMultiplier).toFixed(2)}. ` +\n         `Waiting for RSI > ${this.rsiResetLevel} reset before next entry.`);\n      return;\n    }\n\n    // Get current price and calculate ATR for position sizing\n    const mids = await getAllMids();\n    const currentPrice = parseFloat(mids[this.coin]);\n    \n    // Fetch candles for ATR calculation\n    const endTime = Date.now();\n    const startTime = endTime - (50 * 60 * 60 * 1000);  // 50 hours for 1h candles\n    const candles = await getCandleSnapshot(this.coin, this.interval, startTime, endTime);\n    \n    if (candles.length < 20) {\n      await this.updateState('error', { coin: this.coin, candleCount: candles.length },\n        `${this.coin}: Insufficient candle data (${candles.length} candles). Need 20+ for ATR. Will retry.`);\n      return;\n    }\n\n    // Calculate ATR manually (14-period)\n    const atrPeriod = 14;\n    const trs = [];\n    for (let i = 1; i < candles.length; i++) {\n      const high = candles[i].high;\n      const low = candles[i].low;\n      const prevClose = candles[i - 1].close;\n      const tr = Math.max(\n        high - low,\n        Math.abs(high - prevClose),\n        Math.abs(low - prevClose)\n      );\n      trs.push(tr);\n    }\n    \n    const recentTrs = trs.slice(-atrPeriod);\n    const atr = recentTrs.reduce((sum, tr) => sum + tr, 0) / recentTrs.length;\n\n    // STEP 4: ATR-based position sizing\n    // Risk $2 with stop at 1.5x ATR\n    // size = riskDollars / stopDistance\n    const stopDistance = this.atrMultiplier * atr;\n    const size = this.riskPerTrade / stopDistance;\n    const notional = size * currentPrice;\n\n    // Validate minimum notional\n    if (notional < 10) {\n      await this.updateState('skip_min_size', {\n        coin: this.coin,\n        notional: notional.toFixed(2),\n        size: size.toFixed(6),\n        atr: atr.toFixed(2),\n        stopDistance: stopDistance.toFixed(2)\n      }, `${this.coin}: Calculated position size ${size.toFixed(6)} BTC ($${notional.toFixed(2)} notional) ` +\n         `below $10 minimum. ATR=$${atr.toFixed(2)}, stop distance=$${stopDistance.toFixed(2)}. Skipping trade.`);\n      return;\n    }\n\n    // Check safety limits\n    const safetyCheck = await this.checkSafetyLimits(this.coin, size);\n    if (!safetyCheck.allowed) {\n      await this.updateState('safety_block', { coin: this.coin, reason: safetyCheck.reason },\n        `${this.coin}: Trade blocked by safety limits — ${safetyCheck.reason}`);\n      return;\n    }\n\n    // Validate against max trade size\n    const maxSizes = await this.orderExecutor.getMaxTradeSizes(this.coin);\n    const adjustedSize = Math.min(size, maxSizes.maxLong * 0.95);  // 95% of max for safety\n    \n    if (adjustedSize < size * 0.5) {\n      await this.updateState('insufficient_margin', {\n        coin: this.coin,\n        requestedSize: size.toFixed(6),\n        maxSize: maxSizes.maxLong.toFixed(6)\n      }, `${this.coin}: Insufficient margin. Requested ${size.toFixed(6)} BTC but max available is ${maxSizes.maxLong.toFixed(6)}. ` +\n         `Need more balance for this trade size.`);\n      return;\n    }\n\n    // Pattern 6: Fee viability check (optional but good practice)\n    const { totalFee } = this.orderExecutor.estimateRoundTripFee(adjustedSize, currentPrice);\n    const feePercent = (totalFee / this.riskPerTrade) * 100;\n\n    // Place market order\n    const orderResult = await this.orderExecutor.placeMarketOrder(this.coin, true, adjustedSize, false, 0.05);\n    \n    if (!orderResult.success) {\n      await this.updateState('order_failed', {\n        coin: this.coin,\n        error: orderResult.error,\n        size: adjustedSize.toFixed(6)\n      }, `${this.coin}: Order failed — ${orderResult.error}. Will retry on next signal.`);\n      return;\n    }\n\n    // Use filled data with fallbacks (Pattern 1)\n    const filled = orderResult.filledSize || adjustedSize;\n    const fillPrice = orderResult.averagePrice || currentPrice;\n    \n    // Calculate stop loss price (1.5x ATR below entry)\n    const slPrice = fillPrice - stopDistance;\n\n    // Place stop loss (isBuy=false for long position close)\n    const slResult = await this.orderExecutor.placeStopLoss(this.coin, false, filled, slPrice, null, true);\n    \n    if (slResult.success) {\n      this.registerSlTpOrders(this.coin, { sl: slResult });\n    }\n\n    // Log trade\n    const rsiValue = subResults.find(r => r.indicator === 'RSI')?.value;\n    const macdValue = subResults.find(r => r.indicator === 'MACD')?.value?.histogram;\n    \n    await this.logTrade({\n      coin: this.coin,\n      side: 'buy',\n      size: filled,\n      price: fillPrice,\n      order_type: 'market',\n      order_id: orderResult.orderId,\n      trigger_reason: `RSI=${rsiValue?.toFixed(1)} (<${this.rsiThreshold}) AND MACD histogram=${macdValue?.toFixed(2)} (>0)`,\n      is_entry: true,\n      fee: orderResult.fee,\n      fee_rate: orderResult.feeRate\n    });\n\n    await this.reconcileTrackedPositions();\n\n    // Update state tracking (Pattern 7)\n    this.tradeState = {\n      ideaActive: true,\n      entryPrice: fillPrice,\n      entrySize: filled,\n      entryAtr: atr\n    };\n\n    // STEP 5: Detailed entry message\n    const marginUsed = (notional / this.leverage).toFixed(2);\n    await this.updateState('trade_opened', {\n      coin: this.coin,\n      side: 'buy',\n      size: filled.toFixed(6),\n      price: fillPrice.toFixed(2),\n      notional: notional.toFixed(2),\n      leverage: this.leverage,\n      rsi: rsiValue?.toFixed(1),\n      macdHist: macdValue?.toFixed(2),\n      atr: atr.toFixed(2),\n      stopPrice: slPrice.toFixed(2),\n      stopDistance: stopDistance.toFixed(2),\n      riskAmount: this.riskPerTrade.toFixed(2),\n      fee: totalFee.toFixed(4),\n      feePercent: feePercent.toFixed(1)\n    }, `${this.coin}: Opened LONG — ${filled.toFixed(6)} BTC @ $${fillPrice.toFixed(2)} ($${notional.toFixed(2)} notional, ${this.leverage}x lev, $${marginUsed} margin). ` +\n       `Triggered by RSI=${rsiValue?.toFixed(1)} (threshold: <${this.rsiThreshold}) AND MACD histogram=${macdValue?.toFixed(2)} (>0). ` +\n       `ATR=$${atr.toFixed(2)}. Stop loss at $${slPrice.toFixed(2)} (${this.atrMultiplier}× ATR = $${stopDistance.toFixed(2)} below entry). ` +\n       `Risking $${this.riskPerTrade.toFixed(2)} on this trade. Est. round-trip fees: $${totalFee.toFixed(4)} (${feePercent.toFixed(1)}% of risk).`);\n    \n    return;\n  }\n\n  // MONITORING LOGIC — Scheduled trigger for exit conditions\n  if (action === 'monitor') {\n    // If no position, just report status\n    if (!this.tradeState.ideaActive) {\n      // Fetch current indicators for status report\n      const endTime = Date.now();\n      const startTime = endTime - (50 * 60 * 60 * 1000);\n      const candles = await getCandleSnapshot(this.coin, this.interval, startTime, endTime);\n      \n      if (candles.length < 20) {\n        await this.updateState('idle', { coin: this.coin },\n          `${this.coin}: Waiting for sufficient data. Next check in 1 minute.`);\n        return;\n      }\n\n      // Calculate RSI\n      const closes = candles.map(c => c.close);\n      const gains = [], losses = [];\n      for (let i = 1; i < closes.length; i++) {\n        const change = closes[i] - closes[i - 1];\n        gains.push(change > 0 ? change : 0);\n        losses.push(change < 0 ? -change : 0);\n      }\n      const recentGains = gains.slice(-this.rsiPeriod);\n      const recentLosses = losses.slice(-this.rsiPeriod);\n      const avgGain = recentGains.reduce((s, g) => s + g, 0) / this.rsiPeriod;\n      const avgLoss = recentLosses.reduce((s, l) => s + l, 0) / this.rsiPeriod;\n      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n      const rsi = 100 - (100 / (1 + rs));\n\n      // Calculate MACD histogram\n      const ema = (data, period) => {\n        const k = 2 / (period + 1);\n        let emaVal = data[0];\n        for (let i = 1; i < data.length; i++) {\n          emaVal = data[i] * k + emaVal * (1 - k);\n        }\n        return emaVal;\n      };\n      const ema12 = ema(closes, 12);\n      const ema26 = ema(closes, 26);\n      const macdLine = ema12 - ema26;\n      \n      // For signal line, we'd need MACD history, so approximate\n      const macdHist = macdLine;  // Simplified\n\n      const rsiStatus = rsi < this.rsiThreshold ? '✓ OVERSOLD' : 'neutral';\n      const macdStatus = macdHist > 0 ? '✓ POSITIVE' : 'negative';\n      \n      await this.updateState('idle', {\n        coin: this.coin,\n        rsi: rsi.toFixed(1),\n        rsiThreshold: this.rsiThreshold,\n        macdHist: macdHist.toFixed(2),\n        rsiMet: rsi < this.rsiThreshold,\n        macdMet: macdHist > 0\n      }, `${this.coin}: Analysis complete — no signals. RSI=${rsi.toFixed(1)} (need <${this.rsiThreshold}, currently ${rsiStatus}), ` +\n         `MACD histogram=${macdHist.toFixed(2)} (need >0, currently ${macdStatus}). ` +\n         `Waiting for both conditions to align. Next check in 1 minute.`);\n      return;\n    }\n\n    // We have a position — check exit conditions\n    const endTime = Date.now();\n    const startTime = endTime - (50 * 60 * 60 * 1000);\n    const candles = await getCandleSnapshot(this.coin, this.interval, startTime, endTime);\n    \n    if (candles.length < 20) return;\n\n    // Calculate RSI\n    const closes = candles.map(c => c.close);\n    const gains = [], losses = [];\n    for (let i = 1; i < closes.length; i++) {\n      const change = closes[i] - closes[i - 1];\n      gains.push(change > 0 ? change : 0);\n      losses.push(change < 0 ? -change : 0);\n    }\n    const recentGains = gains.slice(-this.rsiPeriod);\n    const recentLosses = losses.slice(-this.rsiPeriod);\n    const avgGain = recentGains.reduce((s, g) => s + g, 0) / this.rsiPeriod;\n    const avgLoss = recentLosses.reduce((s, l) => s + l, 0) / this.rsiPeriod;\n    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n    const rsi = 100 - (100 / (1 + rs));\n\n    // Calculate MACD histogram\n    const ema = (data, period) => {\n      const k = 2 / (period + 1);\n      let emaVal = data[0];\n      for (let i = 1; i < data.length; i++) {\n        emaVal = data[i] * k + emaVal * (1 - k);\n      }\n      return emaVal;\n    };\n    const ema12 = ema(closes, 12);\n    const ema26 = ema(closes, 26);\n    const macdLine = ema12 - ema26;\n    const macdHist = macdLine;  // Simplified\n\n    // Exit condition 1: RSI crosses above reset level (oversold cleared)\n    const shouldExitRsi = rsi > this.rsiResetLevel;\n    \n    // Exit condition 2: MACD histogram goes negative (momentum lost)\n    const shouldExitMacd = macdHist < 0;\n\n    if (shouldExitRsi || shouldExitMacd) {\n      // Pattern 9: Sandboxed close sequence\n      const mySize = this.tradeState.entrySize;\n      this.clearSlTpOrders(this.coin);\n      await this.orderExecutor.cancelAgentOrders(this.coin);\n      \n      const closeResult = await this.orderExecutor.closePosition(this.coin, mySize);\n      \n      if (!closeResult.success) {\n        await this.updateState('close_failed', {\n          coin: this.coin,\n          error: closeResult.error,\n          rsi: rsi.toFixed(1),\n          macdHist: macdHist.toFixed(2)\n        }, `${this.coin}: Exit signal triggered (RSI=${rsi.toFixed(1)}, MACD hist=${macdHist.toFixed(2)}) ` +\n           `but close failed — ${closeResult.error}. Will retry next cycle.`);\n        return;\n      }\n\n      const exitPrice = closeResult.averagePrice || closes[closes.length - 1];\n      const exitReason = shouldExitRsi \n        ? `RSI crossed above ${this.rsiResetLevel} (now ${rsi.toFixed(1)})` \n        : `MACD histogram turned negative (now ${macdHist.toFixed(2)})`;\n\n      await this.logTrade({\n        coin: this.coin,\n        side: 'sell',\n        size: mySize,\n        price: exitPrice,\n        order_type: 'market',\n        trigger_reason: exitReason,\n        is_exit: true\n      });\n\n      await this.reconcileTrackedPositions();\n\n      // Get PnL from tracker\n      const recentClosed = this.getTrackedClosedPositions(this.coin, 1);\n      const pnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n\n      // Reset state\n      const prevEntry = this.tradeState.entryPrice;\n      this.tradeState = { ideaActive: false, entryPrice: null, entrySize: 0, entryAtr: null };\n\n      await this.updateState('position_closed', {\n        coin: this.coin,\n        exitReason,\n        size: mySize.toFixed(6),\n        entryPrice: prevEntry.toFixed(2),\n        exitPrice: exitPrice.toFixed(2),\n        pnl: pnl?.net?.toFixed(2),\n        pnlPercent: pnl?.percent?.toFixed(2),\n        rsi: rsi.toFixed(1),\n        macdHist: macdHist.toFixed(2)\n      }, `${this.coin}: Closed position — ${exitReason}. Sold ${mySize.toFixed(6)} BTC @ $${exitPrice.toFixed(2)} ` +\n         `(entered @ $${prevEntry.toFixed(2)})` +\n         (pnl ? `. PnL: $${pnl.net.toFixed(2)} (${pnl.percent.toFixed(2)}%)` : '') +\n         `. State reset — ready for next RSI < ${this.rsiThreshold} signal.`);\n    }\n  }\n\n} catch (error) {\n  await this.updateState('error', {\n    coin: this.coin,\n    error: error.message,\n    stack: error.stack\n  }, `${this.coin}: Error in executeTrade — ${error.message}. Will retry on next trigger.`);\n  this.log(`Error in executeTrade: ${error.message}`, 'error');\n}",
    "error": null
}
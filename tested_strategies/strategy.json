{
    "success": true,
    "initialization_code": "try {\n  // STEP 1: STRATEGY CLASSIFICATION\n  // This is a MEAN REVERSION strategy. RSI below 40 = oversold (buy), RSI above 60 = overbought (sell).\n  // Re-entry rule: One trade per excursion. After entering on RSI < 40, do NOT re-enter while RSI\n  // stays low. Must wait for RSI to return above 50 (neutral) before next buy signal is valid.\n\n  // STEP 2: PARAMETERS\n  this.coin = 'BTC';\n  this.tradeNotional = 10; // $10 total position value (including leverage)\n  this.leverage = 5;\n  this.rsiPeriod = 14;\n  this.rsiInterval = '1h'; // 1-hour candles for RSI calculation\n  this.rsiBuyThreshold = 40;\n  this.rsiSellThreshold = 60;\n  this.rsiResetThreshold = 50; // Neutral level — must cross this to reset trade idea\n\n  // STEP 3: RISK MANAGEMENT (ROI-based)\n  // User specified 5% profit, 3% loss. These are ROI on margin.\n  // Convert to price moves: priceMove = roiPercent / 100 / leverage\n  this.tpRoiPct = 5; // 5% ROI = 1% price move at 5x leverage\n  this.slRoiPct = 3; // 3% ROI = 0.6% price move at 5x leverage\n  this.tpPriceMove = this.tpRoiPct / 100 / this.leverage; // 0.01 (1%)\n  this.slPriceMove = this.slRoiPct / 100 / this.leverage; // 0.006 (0.6%)\n\n  // STEP 4: TRADE STATE TRACKING (prevents duplicate entries from same excursion)\n  this.tradeState = {\n    ideaActive: false, // Is there an active trade idea (position open)?\n    lastSignal: null,  // 'buy' or 'sell' — which signal triggered the current position\n    entryPrice: null,  // Entry price for current position\n    entrySize: 0,      // Size of current position (for sandboxed closing)\n    lastRsiValue: null // Track RSI to detect reset crossings\n  };\n\n  // STEP 5: SET LEVERAGE (must be done BEFORE any orders)\n  await this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n\n  // STEP 6: ESTIMATE FEES (report to user for transparency)\n  const mids = await getAllMids();\n  const currentPrice = parseFloat(mids[this.coin]);\n  const estimatedSize = this.tradeNotional / currentPrice;\n  const { totalFee } = this.orderExecutor.estimateRoundTripFee(estimatedSize, currentPrice);\n  const expectedProfit = this.tradeNotional * this.tpPriceMove;\n\n  // STEP 7: INITIALIZATION MESSAGE (tell user the full plan)\n  await this.updateState('init', {\n    coin: this.coin,\n    leverage: this.leverage,\n    tradeNotional: this.tradeNotional,\n    rsiBuy: this.rsiBuyThreshold,\n    rsiSell: this.rsiSellThreshold,\n    rsiReset: this.rsiResetThreshold,\n    tpRoi: this.tpRoiPct,\n    slRoi: this.slRoiPct,\n    tpPriceMove: (this.tpPriceMove * 100).toFixed(2),\n    slPriceMove: (this.slPriceMove * 100).toFixed(2),\n    estimatedFee: totalFee.toFixed(4),\n    expectedProfit: expectedProfit.toFixed(4)\n  }, `RSI Mean Reversion Strategy initialized on ${this.coin}. ` +\n     `Will BUY when RSI < ${this.rsiBuyThreshold} (oversold) and SELL when RSI > ${this.rsiSellThreshold} (overbought). ` +\n     `Trade size: $${this.tradeNotional} notional at ${this.leverage}x leverage ($${(this.tradeNotional/this.leverage).toFixed(2)} margin per trade). ` +\n     `Risk: ${this.slRoiPct}% SL (${(this.slPriceMove * 100).toFixed(1)}% price move), ` +\n     `${this.tpRoiPct}% TP (${(this.tpPriceMove * 100).toFixed(1)}% price move). ` +\n     `RSI calculated on ${this.rsiInterval} candles (period ${this.rsiPeriod}). ` +\n     `Estimated round-trip fees: $${totalFee.toFixed(4)} (${((totalFee/expectedProfit)*100).toFixed(1)}% of expected profit). ` +\n     `Checking every minute. Ready to trade.`);\n} catch (error) {\n  await this.updateState('init_error', {\n    error: error.message,\n    stack: error.stack\n  }, `Initialization failed: ${error.message}`);\n  throw error;\n}",
    "trigger_code": "// STEP 1: REGISTER RSI BUY TRIGGER (fires when RSI crosses below 40)\n// This uses the built-in technical trigger system which:\n// - Fetches candle history every ~60 seconds\n// - Calculates RSI(14) on 1h candles\n// - Edge-detects when RSI crosses below 40 (fires once, not continuously)\nthis.registerTechnicalTrigger(\n  this.coin,\n  'RSI',\n  { period: this.rsiPeriod, interval: this.rsiInterval },\n  { crosses_below: this.rsiBuyThreshold },\n  async (triggerData) => {\n    // Pass action='buy' to executeTrade so it knows this is a buy signal\n    await this.executeTrade({ ...triggerData, action: 'buy' });\n  }\n);\n\n// STEP 2: REGISTER RSI SELL TRIGGER (fires when RSI crosses above 60)\nthis.registerTechnicalTrigger(\n  this.coin,\n  'RSI',\n  { period: this.rsiPeriod, interval: this.rsiInterval },\n  { crosses_above: this.rsiSellThreshold },\n  async (triggerData) => {\n    // Pass action='sell' to executeTrade so it knows this is a sell signal\n    await this.executeTrade({ ...triggerData, action: 'sell' });\n  }\n);\n\n// STEP 3: REGISTER SCHEDULED TRIGGER (periodic RSI monitoring for reset detection)\n// This checks RSI every minute to:\n// - Detect when RSI returns to neutral (crosses 50) to reset trade ideas\n// - Provide periodic status updates when no signals are active\n// - Detect external closes (SL/TP hits)\nthis.registerScheduledTrigger(\n  60000, // 60 seconds\n  async (triggerData) => {\n    await this.executeTrade({ ...triggerData, action: 'monitor' });\n  }\n);\n\nawait this.updateState('triggers_registered', {\n  coin: this.coin,\n  buyThreshold: this.rsiBuyThreshold,\n  sellThreshold: this.rsiSellThreshold,\n  monitorInterval: 60\n}, `Triggers registered: RSI buy <${this.rsiBuyThreshold}, sell >${this.rsiSellThreshold}, monitoring every 60s.`);",
    "execution_code": "try {\n  const coin = this.coin;\n  let action = triggerData.action; // 'buy', 'sell', or 'monitor'\n\n  // STEP 1: DETECT EXTERNAL CLOSES (SL/TP hits)\n  // Use position tracker (sandboxing-safe) to check if our position still exists\n  if (this.tradeState.ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(coin);\n    if (!trackedPos) {\n      // Position was closed externally (SL or TP hit)\n      const prev = { ...this.tradeState };\n      this.tradeState = {\n        ideaActive: false,\n        lastSignal: null,\n        entryPrice: null,\n        entrySize: 0,\n        lastRsiValue: null\n      };\n      \n      // Get PnL from closed position history\n      const closedPositions = this.positionTracker.getClosedPositions(coin);\n      let lastPnl = null;\n      if (closedPositions && closedPositions.length > 0) {\n        lastPnl = closedPositions[closedPositions.length - 1].pnl;\n      }\n      \n      await this.updateState('external_close', {\n        coin,\n        prevSignal: prev.lastSignal,\n        prevEntry: prev.entryPrice,\n        prevSize: prev.entrySize,\n        pnl: lastPnl ? lastPnl.net.toFixed(4) : null,\n        pnlPercent: lastPnl ? lastPnl.percent.toFixed(2) : null\n      }, `${coin}: Position closed externally (SL/TP hit). ` +\n         `Was ${prev.lastSignal?.toUpperCase()} ${prev.entrySize?.toFixed(6)} BTC @ $${prev.entryPrice?.toFixed(2)}` +\n         (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent > 0 ? '+' : ''}${lastPnl.percent.toFixed(2)}%)` : '') +\n         `. State reset — ready for next RSI signal.`);\n      return;\n    }\n  }\n\n  // STEP 2: GET CURRENT MARKET DATA\n  const mids = await getAllMids();\n  const currentPrice = parseFloat(mids[coin]);\n  \n  // Get current RSI value for monitoring and reset detection\n  let currentRsi = null;\n  if (triggerData.type === 'technical' && triggerData.indicator === 'RSI') {\n    currentRsi = triggerData.value;\n  } else if (action === 'monitor') {\n    // For scheduled monitoring, fetch candles and calculate RSI manually\n    const endTime = Date.now();\n    const startTime = endTime - (this.rsiPeriod + 10) * 60 * 60 * 1000; // Extra candles for RSI calculation\n    const candles = await getCandleSnapshot(coin, this.rsiInterval, startTime, endTime);\n    \n    if (candles.length >= this.rsiPeriod + 1) {\n      // Simple RSI calculation (Wilder's smoothing approximation)\n      let gains = 0, losses = 0;\n      for (let i = 1; i < Math.min(this.rsiPeriod + 1, candles.length); i++) {\n        const change = candles[i].close - candles[i - 1].close;\n        if (change > 0) gains += change;\n        else losses += Math.abs(change);\n      }\n      const avgGain = gains / this.rsiPeriod;\n      let avgLoss = losses / this.rsiPeriod;\n      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n      currentRsi = 100 - (100 / (1 + rs));\n    }\n  }\n\n  // STEP 3: CHECK FOR RSI RESET (mean reversion lifecycle)\n  // If RSI crosses back to neutral (50), reset the trade idea so we can re-enter on next excursion\n  if (currentRsi !== null && this.tradeState.lastRsiValue !== null && !this.tradeState.ideaActive) {\n    const crossedReset = \n      (this.tradeState.lastSignal === 'buy' && this.tradeState.lastRsiValue < this.rsiResetThreshold && currentRsi >= this.rsiResetThreshold) ||\n      (this.tradeState.lastSignal === 'sell' && this.tradeState.lastRsiValue > this.rsiResetThreshold && currentRsi <= this.rsiResetThreshold);\n    \n    if (crossedReset) {\n      let prevSignal = this.tradeState.lastSignal;\n      this.tradeState.lastSignal = null; // Clear signal — ready for new entry\n      await this.updateState('rsi_reset', {\n        coin,\n        rsi: currentRsi.toFixed(2),\n        resetThreshold: this.rsiResetThreshold,\n        prevSignal\n      }, `${coin}: RSI returned to neutral (${currentRsi.toFixed(2)} crossed ${this.rsiResetThreshold}). ` +\n         `Previous ${prevSignal?.toUpperCase()} idea reset — ready for next ${prevSignal === 'buy' ? 'oversold' : 'overbought'} signal.`);\n    }\n  }\n  \n  // Update last RSI value for next cycle\n  if (currentRsi !== null) {\n    this.tradeState.lastRsiValue = currentRsi;\n  }\n\n  // STEP 4: HANDLE MONITOR ACTION (periodic status, no trade)\n  if (action === 'monitor') {\n    // Just monitoring — report status if RSI is available\n    if (currentRsi !== null) {\n      const status = currentRsi < this.rsiBuyThreshold ? 'oversold' :\n                     currentRsi > this.rsiSellThreshold ? 'overbought' : 'neutral';\n      const nextSignal = this.tradeState.ideaActive ? \n        `Holding ${this.tradeState.lastSignal?.toUpperCase()} position (${this.tradeState.entrySize?.toFixed(6)} BTC @ $${this.tradeState.entryPrice?.toFixed(2)})` :\n        this.tradeState.lastSignal ? \n          `Waiting for RSI to cross ${this.rsiResetThreshold} to reset ${this.tradeState.lastSignal} idea` :\n          `Ready for next signal (buy <${this.rsiBuyThreshold}, sell >${this.rsiSellThreshold})`;\n      \n      await this.updateState('monitor', {\n        coin,\n        rsi: currentRsi.toFixed(2),\n        status,\n        price: currentPrice.toFixed(2)\n      }, `${coin}: RSI at ${currentRsi.toFixed(2)} (${status}). ${nextSignal}. Next check in 1 minute.`);\n    }\n    return;\n  }\n\n  // STEP 5: VALIDATE TRADE SIGNAL (prevent duplicate entries from same excursion)\n  if (action === 'buy' || action === 'sell') {\n    // Check if we already have a position from this signal type\n    if (this.tradeState.ideaActive && this.tradeState.lastSignal === action) {\n      await this.updateState('skip_duplicate', {\n        coin,\n        action,\n        rsi: currentRsi?.toFixed(2),\n        entryPrice: this.tradeState.entryPrice,\n        entrySize: this.tradeState.entrySize\n      }, `${coin}: RSI ${action === 'buy' ? 'still oversold' : 'still overbought'} (${currentRsi?.toFixed(2)}) ` +\n         `but already holding ${action.toUpperCase()} from this excursion ` +\n         `(${this.tradeState.entrySize.toFixed(6)} BTC @ $${this.tradeState.entryPrice.toFixed(2)}). ` +\n         `Waiting for RSI to reset above ${this.rsiResetThreshold} before next ${action}.`);\n      return;\n    }\n\n    // Check if we need to close opposite position first (signal reversal)\n    if (this.tradeState.ideaActive && this.tradeState.lastSignal !== action) {\n      await this.updateState('signal_reversal', {\n        coin,\n        newSignal: action,\n        oldSignal: this.tradeState.lastSignal,\n        rsi: currentRsi?.toFixed(2)\n      }, `${coin}: RSI ${action === 'buy' ? 'crossed below 40 (oversold)' : 'crossed above 60 (overbought)'} ` +\n         `(${currentRsi?.toFixed(2)}). Closing previous ${this.tradeState.lastSignal?.toUpperCase()} position, ` +\n         `opening new ${action.toUpperCase()}.`);\n      \n      // Close existing position (sandboxed close)\n      const closeSize = this.tradeState.entrySize;\n      const wasLong = this.tradeState.lastSignal === 'buy';\n      \n      this.clearSlTpOrders(coin);\n      await this.orderExecutor.cancelAgentOrders(coin);\n      \n      const closeResult = await this.orderExecutor.closePosition(coin, closeSize);\n      if (!closeResult.success) {\n        await this.updateState('close_failed', {\n          coin,\n          error: closeResult.error\n        }, `${coin}: Failed to close ${this.tradeState.lastSignal?.toUpperCase()} position — ${closeResult.error}. ` +\n           `Will retry on next trigger.`);\n        return;\n      }\n      \n      // Log the close\n      await this.logTrade({\n        coin,\n        side: wasLong ? 'sell' : 'buy',\n        size: closeSize,\n        price: closeResult.averagePrice,\n        order_type: 'close_position',\n        is_exit: true,\n        trigger_reason: `RSI signal reversal to ${action}`\n      });\n      \n      await this.reconcileTrackedPositions();\n      \n      // Reset state\n      this.tradeState.ideaActive = false;\n      this.tradeState.lastSignal = null;\n      this.tradeState.entryPrice = null;\n      this.tradeState.entrySize = 0;\n    }\n  }\n\n  // STEP 6: EXECUTE NEW TRADE\n  if (action === 'buy' || action === 'sell') {\n    const isBuy = action === 'buy';\n    \n    // Calculate position size from notional\n    const size = this.tradeNotional / currentPrice;\n    const notional = size * currentPrice;\n    \n    // Validate minimum notional ($10)\n    if (notional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin,\n        notional: notional.toFixed(2)\n      }, `${coin}: Position $${notional.toFixed(2)} below $10 minimum. Skipping.`);\n      return;\n    }\n    \n    // Check safety limits\n    const safetyCheck = await this.checkSafetyLimits(coin, size);\n    if (!safetyCheck.allowed) {\n      await this.updateState('safety_block', {\n        coin,\n        reason: safetyCheck.reason\n      }, `${coin}: Trade blocked — ${safetyCheck.reason}`);\n      return;\n    }\n    \n    // Estimate fees for transparency\n    const { totalFee } = this.orderExecutor.estimateRoundTripFee(size, currentPrice);\n    \n    // Place market order\n    const orderResult = await this.orderExecutor.placeMarketOrder(coin, isBuy, size, false, 0.05);\n    \n    if (!orderResult.success) {\n      await this.updateState('order_failed', {\n        coin,\n        action,\n        error: orderResult.error,\n        size: size.toFixed(6),\n        price: currentPrice.toFixed(2)\n      }, `${coin}: ${action.toUpperCase()} order failed — ${orderResult.error}. Will retry on next signal.`);\n      return;\n    }\n    \n    // Use filled values with fallbacks\n    const filled = orderResult.filledSize || size;\n    const fillPrice = orderResult.averagePrice || currentPrice;\n    const actualNotional = filled * fillPrice;\n    \n    // Calculate SL/TP prices (ROI-based)\n    const slPrice = isBuy ? fillPrice * (1 - this.slPriceMove) : fillPrice * (1 + this.slPriceMove);\n    const tpPrice = isBuy ? fillPrice * (1 + this.tpPriceMove) : fillPrice * (1 - this.tpPriceMove);\n    \n    // Place SL/TP orders\n    const slResult = await this.orderExecutor.placeStopLoss(coin, !isBuy, filled, slPrice, null, true);\n    const tpResult = await this.orderExecutor.placeTakeProfit(coin, !isBuy, filled, tpPrice, null, true);\n    \n    // Register for automatic fill detection\n    this.registerSlTpOrders(coin, { sl: slResult, tp: tpResult });\n    \n    // Log the trade\n    await this.logTrade({\n      coin,\n      side: isBuy ? 'buy' : 'sell',\n      size: filled,\n      price: fillPrice,\n      order_id: orderResult.orderId,\n      order_type: 'market',\n      is_entry: true,\n      trigger_reason: `RSI ${isBuy ? 'oversold' : 'overbought'} (${currentRsi?.toFixed(2)})`\n    });\n    \n    await this.reconcileTrackedPositions();\n    \n    // Update trade state\n    this.tradeState = {\n      ideaActive: true,\n      lastSignal: action,\n      entryPrice: fillPrice,\n      entrySize: filled,\n      lastRsiValue: currentRsi\n    };\n    \n    // Report to user\n    await this.updateState('trade_opened', {\n      coin,\n      side: action,\n      size: filled.toFixed(6),\n      price: fillPrice.toFixed(2),\n      notional: actualNotional.toFixed(2),\n      leverage: this.leverage,\n      rsi: currentRsi?.toFixed(2),\n      slPrice: slPrice.toFixed(2),\n      tpPrice: tpPrice.toFixed(2),\n      slRoi: this.slRoiPct,\n      tpRoi: this.tpRoiPct,\n      estimatedFee: totalFee.toFixed(4)\n    }, `${coin} ${action.toUpperCase()} opened — ${filled.toFixed(6)} BTC @ $${fillPrice.toFixed(2)} ` +\n       `($${actualNotional.toFixed(2)} notional, ${this.leverage}x leverage). ` +\n       `Triggered by RSI=${currentRsi?.toFixed(2)} ${isBuy ? 'crossing below 40 (oversold)' : 'crossing above 60 (overbought)'}. ` +\n       `SL at $${slPrice.toFixed(2)} (-${this.slRoiPct}% ROI), TP at $${tpPrice.toFixed(2)} (+${this.tpRoiPct}% ROI). ` +\n       `Estimated round-trip fees: $${totalFee.toFixed(4)}.`);\n  }\n\n} catch (error) {\n  await this.updateState('error', {\n    coin: this.coin,\n    error: error.message,\n    stack: error.stack\n  }, `${this.coin}: Error in executeTrade — ${error.message}. Will retry on next trigger.`);\n}",
    "error": null
}
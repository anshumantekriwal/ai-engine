{
    "success": true,
    "initialization_code": "// STEP 1: STRATEGY CLASSIFICATION\n// This is event-driven mean reversion. Orderbook imbalance (bid > 3x ask) is a temporary\n// microstructure signal. Enter on imbalance, exit when it flips. One trade per imbalance cycle.\n\n// STEP 4: POSITION MANAGEMENT\n// User specified \"$30 worth\" = NOTIONAL (total position value including leverage).\n// At 5x leverage: margin = $30/5 = $6, size = 30 / currentPrice\nthis.coin = 'BTC';\nthis.tradeNotionalUsd = 30;  // $30 total position value\nthis.leverage = 5;  // Reasonable for quick microstructure trades\nthis.imbalanceThreshold = 3.0;  // Bid must be >= 3x ask to enter\nthis.checkIntervalMs = 10000;  // Check every 10 seconds\n\n// Safety net: exit if price moves against us (in case imbalance never flips)\nthis.safetySlRoiPct = 5;  // 5% ROI loss = 1% price move at 5x leverage\n\n// STEP 3: TRADE IDEA LIFECYCLE\n// Track whether we're in an active imbalance trade\nthis.tradeState = {\n  ideaActive: false,        // Are we in a position from this imbalance?\n  lastSignal: null,         // 'buy' when we entered\n  entryPrice: null,         // Entry price for PnL tracking\n  entrySize: 0,             // Size we opened (for sandboxed close)\n  entryImbalanceRatio: 0,   // Bid/ask ratio when we entered\n  entryTimestamp: null      // When we entered\n};\n\n// STEP 2: DATA ARCHITECTURE\n// WebSocket-driven: live orderbook updates. Store aggregated volumes for analysis.\nthis.bookState = {\n  bestBid: 0,\n  bestAsk: 0,\n  bidVolume: 0,   // Sum of top 5 bid levels (in USD notional)\n  askVolume: 0,   // Sum of top 5 ask levels (in USD notional)\n  imbalanceRatio: 0,  // bidVolume / askVolume\n  lastUpdate: 0\n};\n\n// Set leverage before any trading\nawait this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n\n// STEP 5: LOGGING — detailed init message\nconst slPriceMove = (this.safetySlRoiPct / this.leverage).toFixed(2);\nawait this.updateState('init', {\n  coin: this.coin,\n  notional: this.tradeNotionalUsd,\n  leverage: this.leverage,\n  imbalanceThreshold: this.imbalanceThreshold,\n  checkInterval: this.checkIntervalMs / 1000,\n  safetySlRoi: this.safetySlRoiPct,\n  safetySlPriceMove: slPriceMove\n}, `Orderbook Imbalance Strategy initialized on ${this.coin}. Monitoring top 5 levels of the orderbook. ` +\n   `Will BUY $${this.tradeNotionalUsd} (${this.leverage}x leverage, $${(this.tradeNotionalUsd/this.leverage).toFixed(2)} margin) ` +\n   `when bid volume ≥ ${this.imbalanceThreshold}x ask volume. ` +\n   `Exit when imbalance flips (ask volume ≥ ${this.imbalanceThreshold}x bid volume). ` +\n   `Safety stop-loss: ${this.safetySlRoiPct}% ROI (${slPriceMove}% price move). ` +\n   `Checking every ${this.checkIntervalMs / 1000} seconds.`);",
    "trigger_code": "// STEP 2: DATA ARCHITECTURE\n// Subscribe to L2 orderbook updates via WebSocket (Pattern 3)\n// This feeds live book data into this.bookState, which we analyze in executeTrade\n\nthis.wsManager.subscribeL2Book(this.coin, (data) => {\n  try {\n    const bids = data.levels[0];  // Array of {px, sz, n} — all strings\n    const asks = data.levels[1];\n    \n    if (!bids || !asks || bids.length === 0 || asks.length === 0) return;\n    \n    // Store best bid/ask\n    this.bookState.bestBid = parseFloat(bids[0].px);\n    this.bookState.bestAsk = parseFloat(asks[0].px);\n    \n    // Aggregate top 5 levels — calculate USD notional volume\n    // Volume = sum of (price * size) for each level\n    this.bookState.bidVolume = bids.slice(0, 5).reduce((sum, level) => {\n      const levelPrice = parseFloat(level.px);\n      const levelSize = parseFloat(level.sz);\n      return sum + (levelPrice * levelSize);\n    }, 0);\n    \n    this.bookState.askVolume = asks.slice(0, 5).reduce((sum, level) => {\n      const levelPrice = parseFloat(level.px);\n      const levelSize = parseFloat(level.sz);\n      return sum + (levelPrice * levelSize);\n    }, 0);\n    \n    // Calculate imbalance ratio (bid/ask)\n    this.bookState.imbalanceRatio = this.bookState.askVolume > 0 \n      ? this.bookState.bidVolume / this.bookState.askVolume \n      : 0;\n    \n    this.bookState.lastUpdate = Date.now();\n  } catch (err) {\n    // Silent error handling in callback — don't crash the agent\n    console.error('Error processing L2 book data:', err);\n  }\n});\n\n// Use a scheduled trigger to periodically analyze the stored book state\n// This gives us control over execution timing and prevents over-trading on every tick\nthis.registerScheduledTrigger(this.checkIntervalMs, async (triggerData) => {\n  try {\n    await this.executeTrade({ ...triggerData, source: 'scheduled_check' });\n  } catch (err) {\n    console.error('Error in scheduled trigger:', err);\n    await this.updateState('trigger_error', {\n      coin: this.coin,\n      error: err.message\n    }, `${this.coin}: Scheduled trigger error — ${err.message}`);\n  }\n});",
    "execution_code": "try {\n  // STEP 3: EXTERNAL CLOSE DETECTION (Pattern 8)\n  // Check if position was closed externally (safety SL hit or manual close)\n  if (this.tradeState.ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(this.coin);\n    if (!trackedPos) {\n      // Position closed externally — reset state\n      const prev = { ...this.tradeState };\n      this.tradeState = {\n        ideaActive: false,\n        lastSignal: null,\n        entryPrice: null,\n        entrySize: 0,\n        entryImbalanceRatio: 0,\n        entryTimestamp: null\n      };\n      \n      const recentClosed = this.getTrackedClosedPositions(this.coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n      \n      await this.updateState('external_close', {\n        coin: this.coin,\n        prevEntry: prev.entryPrice,\n        prevSize: prev.entrySize,\n        pnl: lastPnl?.net?.toFixed(4)\n      }, `${this.coin}: Position closed externally (safety SL likely hit). ` +\n         `Was ${prev.entrySize.toFixed(6)} BTC @ $${prev.entryPrice?.toFixed(2)}` +\n         (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}% ROI)` : '') +\n         `. State reset — monitoring for next imbalance.`);\n      return;\n    }\n  }\n  \n  // Validate that we have recent book data\n  if (!this.bookState.lastUpdate || Date.now() - this.bookState.lastUpdate > 30000) {\n    await this.updateState('no_data', { coin: this.coin },\n      `${this.coin}: No recent orderbook data (WebSocket may be reconnecting). Waiting...`);\n    return;\n  }\n  \n  const currentRatio = this.bookState.imbalanceRatio;\n  const bidVol = this.bookState.bidVolume;\n  const askVol = this.bookState.askVolume;\n  const midPrice = (this.bookState.bestBid + this.bookState.bestAsk) / 2;\n  \n  // PHASE 1: CHECK EXIT CONDITIONS (if we have an open position)\n  if (this.tradeState.ideaActive) {\n    // Exit condition: imbalance flipped (ask volume now >= 3x bid volume)\n    const askDominant = currentRatio <= (1 / this.imbalanceThreshold);  // ratio <= 0.33 means ask is 3x+ bid\n    \n    if (askDominant) {\n      // SANDBOXED CLOSE SEQUENCE (Pattern 9)\n      const mySize = this.tradeState.entrySize;\n      this.clearSlTpOrders(this.coin);\n      await this.orderExecutor.cancelAgentOrders(this.coin);\n      \n      const closeResult = await this.orderExecutor.closePosition(this.coin, mySize);\n      \n      if (!closeResult.success) {\n        await this.updateState('close_failed', {\n          coin: this.coin,\n          error: closeResult.error,\n          ratio: currentRatio.toFixed(2)\n        }, `${this.coin}: Imbalance flipped (ask now ${(1/currentRatio).toFixed(2)}x bid) but close failed — ` +\n           `${closeResult.error}. Will retry next cycle.`);\n        return;\n      }\n      \n      const exitPrice = closeResult.averagePrice || midPrice;\n      const pnlResult = await this.logTrade({\n        coin: this.coin,\n        side: 'sell',\n        size: mySize,\n        price: exitPrice,\n        order_type: 'close_position',\n        is_exit: true,\n        trigger_reason: `Orderbook imbalance flipped: ask volume ${(1/currentRatio).toFixed(2)}x bid`\n      });\n      \n      await this.reconcileTrackedPositions();\n      \n      // Reset trade state\n      this.tradeState = {\n        ideaActive: false,\n        lastSignal: null,\n        entryPrice: null,\n        entrySize: 0,\n        entryImbalanceRatio: 0,\n        entryTimestamp: null\n      };\n      \n      await this.updateState('trade_closed', {\n        coin: this.coin,\n        exitPrice: exitPrice.toFixed(2),\n        size: mySize.toFixed(6),\n        exitRatio: currentRatio.toFixed(2),\n        bidVol: (bidVol / 1000).toFixed(1),\n        askVol: (askVol / 1000).toFixed(1),\n        pnl: pnlResult?.pnl?.net?.toFixed(4),\n        pnlPct: pnlResult?.pnl?.percent?.toFixed(2)\n      }, `${this.coin} LONG closed — ${mySize.toFixed(6)} BTC @ $${exitPrice.toFixed(2)}. ` +\n         `Imbalance flipped: ask volume now ${(1/currentRatio).toFixed(2)}x bid ` +\n         `(bid $${(bidVol/1000).toFixed(0)}k vs ask $${(askVol/1000).toFixed(0)}k). ` +\n         (pnlResult?.pnl ? `Realized PnL: $${pnlResult.pnl.net.toFixed(4)} (${pnlResult.pnl.percent.toFixed(2)}% ROI). ` : '') +\n         `Ready for next imbalance signal.`);\n      return;\n    }\n    \n    // Still in position, imbalance hasn't flipped — just monitor\n    await this.updateState('monitoring', {\n      coin: this.coin,\n      ratio: currentRatio.toFixed(2),\n      bidVol: (bidVol / 1000).toFixed(1),\n      askVol: (askVol / 1000).toFixed(1),\n      positionSize: this.tradeState.entrySize.toFixed(6),\n      entryPrice: this.tradeState.entryPrice.toFixed(2)\n    }, `${this.coin}: Bid volume still dominant (${currentRatio.toFixed(2)}x ask), ` +\n       `holding ${this.tradeState.entrySize.toFixed(6)} BTC @ $${this.tradeState.entryPrice.toFixed(2)}. ` +\n       `Monitoring for imbalance flip (need ask ≥ ${this.imbalanceThreshold}x bid).`);\n    return;\n  }\n  \n  // PHASE 2: CHECK ENTRY CONDITIONS (if no position)\n  const bidDominant = currentRatio >= this.imbalanceThreshold;\n  \n  if (bidDominant) {\n    // ENTRY LOGIC\n    // Calculate position size from notional\n    const size = this.tradeNotionalUsd / midPrice;\n    const notional = size * midPrice;\n    \n    // Validate minimum notional\n    if (notional + 1e-8 < 10) {\n      await this.updateState('skip_min_size', {\n        coin: this.coin,\n        notional: notional.toFixed(2)\n      }, `${this.coin}: Imbalance detected (${currentRatio.toFixed(2)}x) but position ` +\n         `$${notional.toFixed(2)} below $10 minimum. Skipping.`);\n      return;\n    }\n    \n    // Check safety limits\n    const safetyCheck = this.checkSafetyLimits(this.coin, size);\n    if (!safetyCheck.allowed) {\n      await this.updateState('skip_safety', {\n        coin: this.coin,\n        reason: safetyCheck.reason,\n        ratio: currentRatio.toFixed(2)\n      }, `${this.coin}: Imbalance signal (${currentRatio.toFixed(2)}x) but blocked by safety: ` +\n         `${safetyCheck.reason}`);\n      return;\n    }\n    \n    // Pre-trade fee check (Pattern 6)\n    const { totalFee } = this.orderExecutor.estimateRoundTripFee(size, midPrice);\n    \n    // Place market buy order\n    const orderResult = await this.orderExecutor.placeMarketOrder(this.coin, true, size, false, 0.05);\n    \n    if (!orderResult.success) {\n      await this.updateState('order_failed', {\n        coin: this.coin,\n        error: orderResult.error,\n        ratio: currentRatio.toFixed(2)\n      }, `${this.coin}: Failed to open LONG (imbalance ${currentRatio.toFixed(2)}x) — ` +\n         `${orderResult.error}. Will retry on next signal.`);\n      return;\n    }\n    \n    const filled = orderResult.filledSize || size;\n    const fillPrice = orderResult.averagePrice || midPrice;\n    const actualNotional = filled * fillPrice;\n    \n    // Place safety stop-loss (in case imbalance never flips)\n    const slMove = this.safetySlRoiPct / 100 / this.leverage;\n    const slPrice = fillPrice * (1 - slMove);\n    const slResult = await this.orderExecutor.placeStopLoss(this.coin, false, filled, slPrice, null, true);\n    \n    if (slResult.success) {\n      this.registerSlTpOrders(this.coin, { sl: slResult });\n    }\n    \n    // Log trade and reconcile\n    await this.logTrade({\n      coin: this.coin,\n      side: 'buy',\n      size: filled,\n      price: fillPrice,\n      order_type: 'market',\n      order_id: orderResult.orderId,\n      is_entry: true,\n      trigger_reason: `Orderbook imbalance: bid volume ${currentRatio.toFixed(2)}x ask`,\n      fee: orderResult.fee,\n      fee_rate: orderResult.feeRate\n    });\n    \n    await this.reconcileTrackedPositions();\n    \n    // Update trade state (Pattern 7)\n    this.tradeState = {\n      ideaActive: true,\n      lastSignal: 'buy',\n      entryPrice: fillPrice,\n      entrySize: filled,\n      entryImbalanceRatio: currentRatio,\n      entryTimestamp: Date.now()\n    };\n    \n    await this.updateState('trade_opened', {\n      coin: this.coin,\n      side: 'LONG',\n      size: filled.toFixed(6),\n      price: fillPrice.toFixed(2),\n      notional: actualNotional.toFixed(2),\n      leverage: this.leverage,\n      ratio: currentRatio.toFixed(2),\n      bidVol: (bidVol / 1000).toFixed(1),\n      askVol: (askVol / 1000).toFixed(1),\n      slPrice: slPrice.toFixed(2),\n      fee: totalFee.toFixed(4)\n    }, `${this.coin} LONG opened — ${filled.toFixed(6)} BTC @ $${fillPrice.toFixed(2)} ` +\n       `($${actualNotional.toFixed(2)} notional, ${this.leverage}x leverage). ` +\n       `Triggered by orderbook imbalance: bid volume ${currentRatio.toFixed(2)}x ask ` +\n       `(bid $${(bidVol/1000).toFixed(0)}k vs ask $${(askVol/1000).toFixed(0)}k). ` +\n       `Will exit when imbalance flips (ask ≥ ${this.imbalanceThreshold}x bid). ` +\n       `Safety SL at $${slPrice.toFixed(2)} (${this.safetySlRoiPct}% ROI). ` +\n       `Estimated round-trip fee: $${totalFee.toFixed(4)}.`);\n    return;\n  }\n  \n  // PHASE 3: NO SIGNAL — report current state (Pattern 12)\n  await this.updateState('no_signal', {\n    coin: this.coin,\n    ratio: currentRatio.toFixed(2),\n    bidVol: (bidVol / 1000).toFixed(1),\n    askVol: (askVol / 1000).toFixed(1),\n    threshold: this.imbalanceThreshold\n  }, `${this.coin}: Orderbook balanced — bid volume ${currentRatio.toFixed(2)}x ask ` +\n     `(bid $${(bidVol/1000).toFixed(0)}k vs ask $${(askVol/1000).toFixed(0)}k). ` +\n     `Need bid ≥ ${this.imbalanceThreshold}x ask to enter. ` +\n     `Next check in ${this.checkIntervalMs / 1000} seconds.`);\n  \n} catch (error) {\n  await this.updateState('error', {\n    coin: this.coin,\n    error: error.message,\n    stack: error.stack\n  }, `${this.coin}: Error in executeTrade — ${error.message}. Will retry next cycle.`);\n}",
    "error": null
}
{
    "success": true,
    "initialization_code": "// STEP 1 REASONING: Trend-following strategy using EMA 9/21 crossover.\n// This is a momentum strategy — we stay in trades while trend holds, exit on reversal.\n// Conservative approach: moderate leverage (5x), reasonable SL/TP, $100 per trade.\n\nthis.coin = 'BTC';\nthis.leverage = 5;  // Conservative leverage for \"not too risky\"\nthis.tradeAmountUsd = 100;  // $100 notional per trade\nthis.slRoiPct = 8;   // 8% ROI stop-loss = 1.6% price move at 5x\nthis.tpRoiPct = 12;  // 12% ROI take-profit = 2.4% price move at 5x\nthis.interval = '1h';  // Use 1-hour candles for EMA calculation\nthis.checkIntervalMs = 5 * 60 * 1000;  // Check every 5 minutes\n\n// STEP 3: Trade idea lifecycle tracking\nthis.tradeState = {\n  BTC: {\n    ideaActive: false,    // Is there an active trade from a crossover?\n    lastSignal: null,     // 'buy' or 'sell' — which crossover triggered entry\n    entryPrice: null,\n    entrySize: 0,\n    lastEma9: null,       // Previous EMA9 value (for crossover detection)\n    lastEma21: null       // Previous EMA21 value (for crossover detection)\n  }\n};\n\n// STEP 2: WebSocket price cache for real-time price access\nthis.latestPrices = {};\n\n// Helper method: Calculate EMA (Exponential Moving Average)\nthis.calculateEMA = function(data, period) {\n  const k = 2 / (period + 1);\n  const emaArray = [data[0]];  // Start with first value as initial EMA\n  \n  for (let i = 1; i < data.length; i++) {\n    const ema = data[i] * k + emaArray[i - 1] * (1 - k);\n    emaArray.push(ema);\n  }\n  \n  return emaArray;\n};\n\n// Set leverage before any trading\nawait this.orderExecutor.setLeverage(this.coin, this.leverage, true);\n\n// STEP 5: Detailed init message\nconst slPriceMove = (this.slRoiPct / this.leverage).toFixed(1);\nconst tpPriceMove = (this.tpRoiPct / this.leverage).toFixed(1);\n\nawait this.updateState('init', {\n  coin: this.coin,\n  leverage: this.leverage,\n  tradeAmount: this.tradeAmountUsd,\n  slRoi: this.slRoiPct,\n  tpRoi: this.tpRoiPct,\n  interval: this.interval,\n  checkInterval: this.checkIntervalMs / 60000\n}, `Strategy initialized: EMA Crossover (9/21) on BTC. Will open LONG when EMA9 crosses above EMA21, ` +\n   `SHORT when EMA9 crosses below EMA21. Trade size: $${this.tradeAmountUsd} at ${this.leverage}x leverage. ` +\n   `Risk: SL at ${this.slRoiPct}% ROI (${slPriceMove}% price move), ` +\n   `TP at ${this.tpRoiPct}% ROI (${tpPriceMove}% price move). ` +\n   `Checking every ${this.checkIntervalMs / 60000} minutes using ${this.interval} candles. ` +\n   `Conservative trend-following approach — only trades confirmed crossovers.`);\n\nconsole.log('[EMA Crossover Agent] Initialization complete. Leverage set, state initialized.');",
    "trigger_code": "// STEP 2: Hybrid data architecture\n// WebSocket for real-time price cache, scheduled trigger for periodic EMA analysis\n\n// Subscribe to live BTC price updates (Pattern 1)\nthis.wsManager.subscribeAllMids((data) => {\n  for (const [coin, px] of Object.entries(data.mids)) {\n    this.latestPrices[coin] = parseFloat(px);\n  }\n});\n\n// Scheduled trigger: check for EMA crossovers every 5 minutes\nthis.registerScheduledTrigger(this.checkIntervalMs, async (triggerData) => {\n  await this.executeTrade(triggerData);\n});\n\nconsole.log('[EMA Crossover Agent] Triggers registered: WebSocket price feed + 5-minute scheduled checks.');\nawait this.updateState('triggers_ready', { checkInterval: this.checkIntervalMs / 60000 }, \n  `Triggers active: monitoring BTC price via WebSocket, analyzing EMA crossovers every ${this.checkIntervalMs / 60000} minutes.`);",
    "execution_code": "// STEP 3 & 4: Trade idea lifecycle + position management\ntry {\n  const coin = this.coin;\n  \n  // STEP 8: External close detection (Pattern 8) — check if SL/TP closed our position\n  if (this.tradeState[coin].ideaActive) {\n    const trackedPos = this.positionTracker.getOpenPosition(coin);\n    if (!trackedPos) {\n      // Position was closed externally (SL/TP hit)\n      const prev = this.tradeState[coin];\n      const prevEntryPrice = prev.entryPrice;\n      const prevEntrySize = prev.entrySize;\n      \n      this.tradeState[coin] = {\n        ideaActive: false,\n        lastSignal: null,\n        entryPrice: null,\n        entrySize: 0,\n        lastEma9: prev.lastEma9,  // Keep EMA values for continuity\n        lastEma21: prev.lastEma21\n      };\n      \n      const recentClosed = this.getTrackedClosedPositions(coin, 1);\n      const lastPnl = recentClosed.length > 0 ? recentClosed[0].pnl : null;\n      \n      await this.updateState('external_close', {\n        coin,\n        prevEntry: prevEntryPrice,\n        prevSize: prevEntrySize,\n        pnl: lastPnl?.net?.toFixed(4),\n        roiPercent: lastPnl?.percent?.toFixed(2)\n      }, `${coin}: Position closed externally (SL/TP hit). Was ${prevEntrySize.toFixed(6)} BTC @ ` +\n         `$${prevEntryPrice.toFixed(2)}` +\n         (lastPnl ? `. Realized PnL: $${lastPnl.net.toFixed(4)} (${lastPnl.percent.toFixed(2)}% ROI)` : '') +\n         `. State reset — ready for next crossover signal.`);\n      \n      return;  // Done for this cycle\n    }\n  }\n  \n  // Get current price (from WebSocket cache or fallback to HTTP)\n  const currentPrice = this.latestPrices[coin] || parseFloat((await getAllMids())[coin]);\n  \n  // Fetch 1-hour candles for EMA calculation (need at least 50 candles for EMA21 + warmup)\n  const endTime = Date.now();\n  const startTime = endTime - (60 * 60 * 1000 * 60);  // 60 hours of data\n  const candles = await getCandleSnapshot(coin, this.interval, startTime, endTime);\n  \n  if (candles.length < 50) {\n    await this.updateState('insufficient_data', { coin, candleCount: candles.length },\n      `${coin}: Insufficient candle data (${candles.length} candles, need 50+). Waiting for more data.`);\n    return;\n  }\n  \n  // Calculate EMA9 and EMA21\n  const closes = candles.map(c => parseFloat(c.close));\n  const ema9 = this.calculateEMA(closes, 9);\n  const ema21 = this.calculateEMA(closes, 21);\n  \n  // Current EMA values (most recent)\n  const currentEma9 = ema9[ema9.length - 1];\n  const currentEma21 = ema21[ema21.length - 1];\n  \n  // Previous EMA values (for crossover detection)\n  const prevEma9 = this.tradeState[coin].lastEma9 !== null ? this.tradeState[coin].lastEma9 : ema9[ema9.length - 2];\n  const prevEma21 = this.tradeState[coin].lastEma21 !== null ? this.tradeState[coin].lastEma21 : ema21[ema21.length - 2];\n  \n  // Update state with current EMA values for next cycle\n  this.tradeState[coin].lastEma9 = currentEma9;\n  this.tradeState[coin].lastEma21 = currentEma21;\n  \n  // Detect crossovers\n  const bullishCross = prevEma9 <= prevEma21 && currentEma9 > currentEma21;  // EMA9 crossed above EMA21\n  const bearishCross = prevEma9 >= prevEma21 && currentEma9 < currentEma21;  // EMA9 crossed below EMA21\n  \n  // PHASE 1: Check for exit signal (opposite crossover)\n  if (this.tradeState[coin].ideaActive) {\n    const wasLong = this.tradeState[coin].lastSignal === 'buy';\n    const shouldExit = (wasLong && bearishCross) || (!wasLong && bullishCross);\n    \n    if (shouldExit) {\n      // Opposite crossover detected — close position (Pattern 9)\n      const mySize = this.tradeState[coin].entrySize;\n      const prevEntryPrice = this.tradeState[coin].entryPrice;\n      \n      this.clearSlTpOrders(coin);\n      await this.orderExecutor.cancelAgentOrders(coin);\n      \n      const closeResult = await this.orderExecutor.closePosition(coin, mySize);\n      if (!closeResult.success) {\n        await this.updateState('close_failed', { coin, error: closeResult.error },\n          `${coin}: Failed to close position — ${closeResult.error}. Will retry next cycle.`);\n        return;\n      }\n      \n      const exitPrice = closeResult.averagePrice || currentPrice;\n      await this.logTrade({\n        coin,\n        side: wasLong ? 'sell' : 'buy',\n        size: mySize,\n        price: exitPrice,\n        order_type: 'close_position',\n        is_exit: true,\n        trigger_reason: `EMA crossover reversal (EMA9: $${currentEma9.toFixed(2)}, EMA21: $${currentEma21.toFixed(2)})`\n      });\n      \n      await this.reconcileTrackedPositions();\n      \n      const pnl = this.getTrackedClosedPositions(coin, 1)[0]?.pnl;\n      this.tradeState[coin].ideaActive = false;\n      this.tradeState[coin].lastSignal = null;\n      this.tradeState[coin].entryPrice = null;\n      this.tradeState[coin].entrySize = 0;\n      \n      await this.updateState('position_closed', {\n        coin,\n        exitPrice,\n        entryPrice: prevEntryPrice,\n        pnl: pnl?.net?.toFixed(4),\n        roiPercent: pnl?.percent?.toFixed(2),\n        ema9: currentEma9.toFixed(2),\n        ema21: currentEma21.toFixed(2)\n      }, `${coin}: Closed ${wasLong ? 'LONG' : 'SHORT'} — ${mySize.toFixed(6)} BTC @ $${exitPrice.toFixed(2)} ` +\n         `(entry: $${prevEntryPrice.toFixed(2)}). Triggered by EMA9 ($${currentEma9.toFixed(2)}) ` +\n         `crossing ${wasLong ? 'below' : 'above'} EMA21 ($${currentEma21.toFixed(2)}) — trend reversal. ` +\n         (pnl ? `Realized PnL: $${pnl.net.toFixed(4)} (${pnl.percent.toFixed(2)}% ROI). ` : '') +\n         `Ready for next crossover.`);\n      \n      return;  // Exit handled, done for this cycle\n    }\n  }\n  \n  // PHASE 2: Check for entry signal (new crossover)\n  if (!this.tradeState[coin].ideaActive) {\n    if (bullishCross || bearishCross) {\n      const isBuy = bullishCross;\n      const action = isBuy ? 'buy' : 'sell';\n      \n      // Calculate position size (Pattern 4)\n      const size = this.tradeAmountUsd / currentPrice;\n      const notional = size * currentPrice;\n      \n      // Validate minimum notional\n      if (notional + 1e-8 < 10) {\n        await this.updateState('skip_min_size', { coin, notional: notional.toFixed(2) },\n          `${coin}: Position $${notional.toFixed(2)} below $10 minimum. Skipping crossover signal.`);\n        return;\n      }\n      \n      // Check safety limits\n      const safetyCheck = await this.checkSafetyLimits(coin, size);\n      if (!safetyCheck.allowed) {\n        await this.updateState('skip_safety', { coin, reason: safetyCheck.reason },\n          `${coin}: Cannot open position — ${safetyCheck.reason}.`);\n        return;\n      }\n      \n      // STEP 6: Pre-trade fee viability check (Pattern 6)\n      const tpPriceMove = this.tpRoiPct / 100 / this.leverage;\n      const { totalFee } = this.orderExecutor.estimateRoundTripFee(size, currentPrice);\n      const expectedGrossProfit = size * currentPrice * tpPriceMove;\n      \n      if (expectedGrossProfit < totalFee * 1.5) {\n        await this.updateState('skip_fee_viability', { \n          coin, \n          expectedProfit: expectedGrossProfit.toFixed(4), \n          totalFee: totalFee.toFixed(4) \n        }, `${coin}: Trade not viable — expected profit $${expectedGrossProfit.toFixed(4)} ` +\n           `does not sufficiently exceed fees $${totalFee.toFixed(4)}. Skipping.`);\n        return;\n      }\n      \n      // Place market order\n      const orderResult = await this.orderExecutor.placeMarketOrder(coin, isBuy, size, false, 0.05);\n      if (!orderResult.success) {\n        await this.updateState('order_failed', { coin, error: orderResult.error },\n          `${coin}: Order failed — ${orderResult.error}. Will retry on next crossover.`);\n        return;\n      }\n      \n      const filled = orderResult.filledSize || size;\n      const fillPrice = orderResult.averagePrice || currentPrice;\n      \n      // Calculate SL/TP prices (Pattern 5 — ROI-based)\n      const slMove = this.slRoiPct / 100 / this.leverage;\n      const tpMove = this.tpRoiPct / 100 / this.leverage;\n      const slPrice = isBuy ? fillPrice * (1 - slMove) : fillPrice * (1 + slMove);\n      const tpPrice = isBuy ? fillPrice * (1 + tpMove) : fillPrice * (1 - tpMove);\n      \n      // Place SL/TP orders\n      const slResult = await this.orderExecutor.placeStopLoss(coin, !isBuy, filled, slPrice, null, true);\n      const tpResult = await this.orderExecutor.placeTakeProfit(coin, !isBuy, filled, tpPrice, null, true);\n      \n      // Register for automatic fill detection\n      this.registerSlTpOrders(coin, { sl: slResult, tp: tpResult });\n      \n      // Log trade\n      await this.logTrade({\n        coin,\n        side: action,\n        size: filled,\n        price: fillPrice,\n        order_type: 'market',\n        order_id: orderResult.orderId,\n        is_entry: true,\n        trigger_reason: `EMA ${bullishCross ? 'bullish' : 'bearish'} crossover (EMA9: $${currentEma9.toFixed(2)}, EMA21: $${currentEma21.toFixed(2)})`\n      });\n      \n      await this.reconcileTrackedPositions();\n      \n      // Update trade state (Pattern 7)\n      this.tradeState[coin].ideaActive = true;\n      this.tradeState[coin].lastSignal = action;\n      this.tradeState[coin].entryPrice = fillPrice;\n      this.tradeState[coin].entrySize = filled;\n      \n      // Report to user\n      await this.updateState('trade_opened', {\n        coin,\n        side: action.toUpperCase(),\n        size: filled.toFixed(6),\n        price: fillPrice.toFixed(2),\n        notional: (filled * fillPrice).toFixed(2),\n        leverage: this.leverage,\n        slPrice: slPrice.toFixed(2),\n        tpPrice: tpPrice.toFixed(2),\n        ema9: currentEma9.toFixed(2),\n        ema21: currentEma21.toFixed(2),\n        fee: totalFee.toFixed(4)\n      }, `${coin}: Opened ${action.toUpperCase()} — ${filled.toFixed(6)} BTC @ $${fillPrice.toFixed(2)} ` +\n         `($${(filled * fillPrice).toFixed(2)} notional, ${this.leverage}x lev). Triggered by EMA9 ($${currentEma9.toFixed(2)}) ` +\n         `crossing ${bullishCross ? 'above' : 'below'} EMA21 ($${currentEma21.toFixed(2)}). ` +\n         `SL at $${slPrice.toFixed(2)}, TP at $${tpPrice.toFixed(2)}. Est. round-trip fee: $${totalFee.toFixed(4)}.`);\n      \n      return;\n    }\n  }\n  \n  // PHASE 3: No action needed — report current state (STEP 5: idle cycle logging)\n  const posStatus = this.tradeState[coin].ideaActive\n    ? `In ${this.tradeState[coin].lastSignal.toUpperCase()} position (${this.tradeState[coin].entrySize.toFixed(6)} BTC @ $${this.tradeState[coin].entryPrice.toFixed(2)})`\n    : 'No open position';\n  \n  const crossStatus = currentEma9 > currentEma21 ? 'EMA9 above EMA21 (bullish)' : 'EMA9 below EMA21 (bearish)';\n  const gapPercent = (Math.abs(currentEma9 - currentEma21) / currentEma21 * 100).toFixed(2);\n  \n  await this.updateState('cycle_summary', {\n    coin,\n    ema9: currentEma9.toFixed(2),\n    ema21: currentEma21.toFixed(2),\n    price: currentPrice.toFixed(2),\n    crossStatus,\n    posStatus\n  }, `${coin}: Analysis complete — no crossover. ${crossStatus} (gap: ${gapPercent}%). ` +\n     `EMA9=$${currentEma9.toFixed(2)}, EMA21=$${currentEma21.toFixed(2)}, Price=$${currentPrice.toFixed(2)}. ` +\n     `${posStatus}. Next check in ${this.checkIntervalMs / 60000} minutes.`);\n  \n} catch (error) {\n  console.error('[EMA Crossover Agent] Error in executeTrade:', error);\n  await this.updateState('error', { error: error.message, stack: error.stack },\n    `Error during analysis: ${error.message}. Will retry on next cycle.`);\n}",
    "error": null
}